<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet
 href="urn:x-suse:xslt:profiling:docbook45-profile.xsl" 
 type="text/xml"
 title="Profiling step"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.docbook.org/xml/4.5/docbookx.dtd"
[<!ENTITY % entities SYSTEM "entity-decl.ent">
%entities;
]>
<chapter id="cha.daps.user.edit">
 <title>Editing DocBook-XML</title>
 <remark>profiling, checklinks, spellcheck, dynamic product names and numbers</remark>
 <abstract>
  &daps-editor;
 </abstract>
<!--taroth 2012-03-08: building an appliance with a pre-configured jedit would
     be a great idea-->
<!--taroth 2012-03-08: another idea: add an appendix chapter with configuration
     tips/instructions for individual editors?-->
 <sect1 id="sec.daps.user.edit.basics">
  <title>Basic Structural Elements</title>
&db-structure-elements;
 </sect1>
 <sect1 id="sec.daps.user.edit.macros">
  <title>Macros for Automatic Insertion of Complex Elements</title>

  <para>
   XML elements can be nested to a high extend. Some constructs like
   <sgmltag>variablelist</sgmltag>, <sgmltag>table</sgmltag> or
   <sgmltag>image</sgmltag> have a lot of required child elements. If you
   have an editor with DTD support, it will tell you which elements are
   allowed at the current cursor position, but nevertheless it is cumbersome
   if you need to insert the child elements of complex XML constructs
   consecutively.
  </para>

  <para>
   Most editors allow you to define or record macros which you can use for
   automatically inserting empty <quote>skeletons</quote> for a complex XML
   construct as illustrated by <xref linkend="ex.daps.user.vle"/>.
  </para>

  <example id="ex.daps.user.vle">
   <title>A <sgmltag>varlistentry</sgmltag>
   </title>
   <screen>&lt;varlistentry&gt;
  &lt;term&gt;&lt;/term&gt;
  &lt;listitem&gt;
    &lt;para&gt;&lt;/para&gt;
  &lt;/listitem&gt;
&lt;/varlistentry&gt;</screen>
  </example>

  <para>
   For Emacs, &dapsacr; already includes macros for adding elements such as
   <sgmltag>listitem</sgmltag>, <sgmltag>figure</sgmltag>,
   <sgmltag>indexterm</sgmltag> etc. The macros are defined in
   <filename>docbook_macros.el</filename> and are added to your system
   during the installation of &dapsacr;. They require that you execute Emacs
   in <literal>psgml</literal>-mode.
  </para>

  <procedure>
   <title>Configuring Emacs to Use the DB Macros</title>
   <step>
    <para>
     To load the DocBook macros, open your Emacs customization file
     (<filename>~/.emacs</filename> or <filename>~/.gnu-emacs</filename>).
    </para>
   </step>
   <step>
    <para>
     Insert the following line:
    </para>
    <screen>(load "/usr/share/emacs/site-lisp/docbook_macros.el" t t)</screen>
   </step>
   <step>
    <para>
     Save the Emacs customization file.
     <remark>taroth 2012-03-13: restart of Emacs needed?</remark>
    </para>
   </step>
  </procedure>

  <para>
   For an overview, which macros are available and how to use them, refer to
   <ulink url="http://en.opensuse.org/openSUSE:Documentation_Emacs_Docbook_Macros"></ulink>.
  </para>
 </sect1>

 <sect1>
  <title>Spell Checking</title>

  <para>&dapsacr; comes with a spell checker that is optimized for DocBook
  documents: Tags and attributes are excluded from the check so that you can
  focus on the content of the document. The spell checker is based on aspell
  and can be run from the command line. By default, it starts in interactive
  mode, but you can also run it in <quote>batch</quote> mode where it dumps 
  a sorted list of misspelled words to standard output. &dapsacr; also allows 
  you to specify a custom dictionary and the language to use for spelling.
  </para>
  <para>In the following, find some examples for using &daps-spell;:</para>
   <!--daps-susespell [options] FILELIST-->
  <variablelist>
   <varlistentry>
    <term>Spell Checking One or Multiple XML Files</term>
    <listitem>
     <screen>&daps-spell; xml/<replaceable>file1</replaceable>.xml xml/<replaceable>file2</replaceable>.xml</screen>
     <para>Checks the specified files with the default dictionary (en_US). 
     Suggests alternative spellings for each misspelled word and waits for user 
     interaction.</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Spell Checking XML Files in Languages Other than English</term>
    <listitem>
     <screen>&daps-spell; --lang=de_DE xml/<replaceable>filename</replaceable>.xml</screen>
     <para>Checks the specified files with the de_DE dictionary (make sure the
     specified aspell dictionary is installed). Suggests alternative spellings 
     for each misspelled word and waits for user interaction. For information 
     about the language code to use for the <option>--lang</option> option, 
     run &daps-spell; --help.</para>
    </listitem>
   </varlistentry>
    <varlistentry>
    <term>Spell Checking XML Files in Batch Mode</term>
    <listitem>
     <screen>&daps-spell; --list xml/<replaceable>filename</replaceable>.xml > aspell_output.txt</screen>
     <para>Checks the specified files with the default dictionary (en_US). Returns 
     a list of misspelled words to standard output and writes them to the file
     <filename>aspell_output.txt</filename>. You can use the  <option>--list</option> 
     option to easily collect a list of words that are unknown to aspell and 
     use this output as basis for a custom aspell wordlist or dictionary.</para>
    </listitem>
   </varlistentry><varlistentry>
    <term>Spell Checking XML Files with an Additional Custom Dictionary</term>
    <listitem>
     <screen></screen>
     <para><!--taroth 2012-05-15: to be continued--></para>
    </listitem>
   </varlistentry>
  </variablelist>
  </sect1>

 <sect1 id="sec.daps.user.edit.validate">
  <title>Validating Your XML Sources</title>

  <para>
   Validating XML files within in a book or set often exceeds validation of
   the current XML file, as links (<sgmltag>xref</sgmltag> elements) or
   XIncludes need to be resolved, too. If you use conditional text
   (<literal>profiling</literal>) in your XML sources (for creating
   variants), your XML editor cannot check validity of your XML files.
   However, &dapsacr; can handle all those cases due to the built-in xmllint
   validator.
  </para>

  <procedure>
   <title>Validating XML Files</title>
   <para>
    To validate all files that belong to your documentation project,
    &dapsacr; only needs to know which &dclong; file to use. If you have
    specified a value for <parameter>DOCCONF_DEFAULT</parameter> in
    &dapsconf-user; or if your documentation directory contains only one
    &dc; file, &dapsacr; automatically uses the corresponding &dc; file.
    Otherwise, specify the path to the &dc; file with the
    <option>-d</option> option as described below.
   </para>
   <para>
    By default, <sgmltag>remark</sgmltag> elements and XML comments are
    ignored during validation. However, if you intend to create a (draft)
    output including remarks or comments, you need to include them for
    validation by specifying the respective &dapsacr; option.
   </para>
   <step>
    <para>
     To validate all XML files in your book, article or set, enter:
    </para>
    <screen>daps -d <replaceable>PATH_TO_DC_FILE</replaceable> validate </screen>
    <para>
     If the XML files are not valid, &dapsacr; will return the parser
     errors. They include information about the type of error, the
     respective file name and the line number where the error occured. In
     addition, &dapsacr; shows the path to the profiled XML sources and the
     total number of errors.
    </para>
    <remark>taroth 2012-03-15: maybe add example output</remark>
    <para>
     If validation was successful, &dapsacr; returns: <literal>All files are
     valid.</literal>
    </para>
   </step>
   <step>
    <para>
     To validate your files including remarks, enter:
    </para>
    <screen>daps -d <replaceable>PATH_TO_DC_FILE</replaceable> validate -r</screen>
   </step>
   <step>
    <para>
     To validate your files including XML comments, enter:
    </para>
    <screen>daps -d <replaceable>PATH_TO_DC_FILE</replaceable> validate -c</screen>
   </step>
  </procedure>

  <example>
   <title>Parser Output For Validation Errors</title>
   <screen>daps_user_concept.xml:60: element xref: validity error : IDREF attribute linkend references an unknown ID "itl.daps.user.inst.other.req"
Document /local/svn/daps-svn/daps/doc/build/.profiled/x86-amd64-em64t_osuse_/MAIN.DAPS.xml does not validate
make: *** [validate] Error 3
</screen>
  </example>
 </sect1>

</chapter>
