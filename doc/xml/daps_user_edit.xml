<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet
 href="urn:x-daps:xslt:profiling:docbook45-profile.xsl" 
 type="text/xml"
 title="Profiling step"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.docbook.org/xml/4.5/docbookx.dtd"
[<!ENTITY % entities SYSTEM "entity-decl.ent">
%entities;
]>
<chapter id="cha.daps.user.edit">
 <title>Editing DocBook-XML</title>
 <remark>profiling, checklinks, spellcheck, dynamic product names and numbers</remark>
 <abstract>
  &daps-editor;
 </abstract>
<!--taroth 2012-03-08: building an appliance with a pre-configured jedit would
     be a great idea-->
<!--taroth 2012-03-08: another idea: add an appendix chapter with configuration
     tips/instructions for individual editors?-->
 <sect1 id="sec.daps.user.edit.basics">
  <title>Basic Structural Elements</title>
&db-structure-elements;
 </sect1>
 <sect1 id="sec.daps.user.edit.macros">
  <title>Editor Macros for Automatic Insertion of Complex Elements</title>

  <para>
   XML elements can be nested to a high extend. Some constructs like
   <sgmltag>variablelist</sgmltag>, <sgmltag>table</sgmltag> or
   <sgmltag>image</sgmltag> have a lot of required child elements. If you
   have an editor with DTD support, it will tell you which elements are
   allowed at the current cursor position, but nevertheless it is cumbersome
   if you need to insert the child elements of complex XML constructs
   consecutively.
  </para>

  <para>
   Most editors allow you to define or record macros which you can use for
   automatically inserting empty <quote>skeletons</quote> for a complex XML
   construct as illustrated by <xref linkend="ex.daps.user.vle"/>.
  </para>

  <example id="ex.daps.user.vle">
   <title>A <sgmltag>varlistentry</sgmltag> Element</title>
   <screen>&lt;varlistentry&gt;
  &lt;term&gt;&lt;/term&gt;
  &lt;listitem&gt;
    &lt;para&gt;&lt;/para&gt;
  &lt;/listitem&gt;
&lt;/varlistentry&gt;</screen>
  </example>

  <para>
   For Emacs, &dapsacr; already includes macros for adding elements such as
   <sgmltag>listitem</sgmltag>, <sgmltag>figure</sgmltag>,
   <sgmltag>indexterm</sgmltag> etc. The macros are defined in
   <filename>docbook_macros.el</filename> and are added to your system
   during the installation of &dapsacr;. They require that you execute Emacs
   in <literal>psgml</literal>-mode.
  </para>

  <procedure>
   <title>Configuring Emacs to Use the DocBook Macros</title>
   <step>
    <para>
     To load the DocBook macros, open your Emacs customization file
     (<filename>~/.emacs</filename> or <filename>~/.gnu-emacs</filename>).
    </para>
   </step>
   <step>
    <para>
     Insert the following line:
    </para>
    <screen>(load "/usr/share/emacs/site-lisp/docbook_macros.el" t t)</screen>
   </step>
   <step>
    <para>
     Save the Emacs customization file.
     <remark>taroth 2012-03-13: restart of Emacs needed?</remark>
    </para>
   </step>
  </procedure>

  <para>
   For an overview, which macros are available and how to use them, refer to
   <ulink url="http://en.opensuse.org/openSUSE:Documentation_Emacs_Docbook_Macros"></ulink>.
  </para>
 </sect1>

 <sect1 id="sec.daps.user.edit.spell">
  <title>Spell Checking</title>

  <para>&dapsacr; comes with a spell checker that is optimized for DocBook
  documents: Tags and attributes are excluded from the check so that you can
  focus on the content of the document. The spell checker is based on &aspell;
  and can be run from the command line. By default, it starts in interactive
  mode, but you can also run it in <quote>batch</quote> mode where it dumps 
  a sorted list of misspelled words to standard output. &dapsacr; also allows 
  you to specify a custom dictionary and the language to use for spelling.
  </para>
  <para>In the following, find some examples for using &daps-spell;:</para>
  <variablelist>
   <varlistentry>
    <term>Spell Checking All Files in a Documentation Project</term>
    <listitem>
     <screen>daps -d <replaceable>PATH_TO_&dc;_FILE</replaceable> spellcheck</screen>
     <para>Spell checks all files in the documentation project with the default 
  dictionary (<literal>en_US</literal>). One by one, the files are opened in 
  interactive mode and checked with &aspell;. To abort spell checking of 
  the current file, press <keycap>X</keycap>. The spell check continues with the
  next file in the project.</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Spell Checking One or Multiple XML Files</term>
    <listitem>
     <screen>&daps-spell; xml/<replaceable>file1</replaceable>.xml xml/<replaceable>file2</replaceable>.xml</screen>
     <para>Checks the specified files with the default dictionary (en_US). 
     Suggests alternative spellings for each misspelled word and waits for user 
     interaction.</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Spell Checking XML Files in Languages Other than English</term>
    <listitem>
     <screen>&daps-spell; --lang=de_DE xml/<replaceable>filename</replaceable>.xml</screen>
     <para>Checks <replaceable>filename</replaceable>.xml with the 
     <literal>de_DE</literal> dictionary (make sure the specified &aspell; 
     dictionary is installed). Suggests alternative spellings for each misspelled
     word and waits for user interaction. For information about the language 
     code to use for the <option>--lang</option> option, run 
     <command>&daps-spell;&nbsp;--help</command>.</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Spell Checking XML Files in Batch Mode</term>
    <listitem>
     <screen>&daps-spell; --list xml/<replaceable>filename</replaceable>.xml > aspell_output.txt</screen>
     <para>Checks <replaceable>filename</replaceable>.xml with the default 
     dictionary (<literal>en_US</literal>). Returns a list of misspelled words 
     to standard output and writes them to the file <filename>aspell_output.txt</filename>. 
     You can use the  <option>--list</option> option to easily collect a list of 
     words that are unknown to &aspell; and use this output as basis for a custom 
     &aspell; word list or dictionary.</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Spell Checking XML Files with an Additional Custom Dictionary</term>
    <listitem>
     <screen>&daps-spell; --dict /<replaceable>PATH_TO_CUSTOM_DICT</replaceable> xml/<replaceable>filename</replaceable>.xml</screen>
     <para>Checks the specified files with the default dictionary 
     (<literal>en_US</literal>) plus the additional custom dictionary specified 
     with <option>--dict</option>. The <option>--dict</option> option requires 
     an absolute path. <remark>taroth 2012-05-16: currently, the SUSE-specific 
     dictionary (/usr/share/daps/lib/suse_aspell.rws) is used in addition per default. 
     "Specify --dict= if you do not want to use any additional dictionary." -
     check with fs (bound to change for the future)</remark>
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
  <para>For your convenience, you can also integrate &daps-spell; (plus a custom 
  &aspell; dictionary, if needed) into your XML editor, so that spelling is checked
  <quote>on the fly</quote> during editing. Consult your editor's documentation 
  on how to integrate a custom dictionary. If you use &jedit;, proceed as outlined
  in <xref linkend="pro.daps.spellcheck.jedit"/>.</para>
  <procedure id="pro.daps.spellcheck.jedit">
   <title>Integrating &daps-spell; into &jedit;</title>
   <para>
    <remark>taroth 2012-05-24: check and adjust as the spellchecker will
   evolve in the future</remark>
   </para>
   <step>
    <para>Start &jedit; and select <menuchoice><guimenu>Plugins</guimenu>
      <guimenu>Plugin Manager</guimenu>
     </menuchoice>.
    </para>
   </step>
   <step>
    <para>If the <guimenu>Spell Check</guimenu> plug-in is not already
    installed, install and activate it.
    </para>
   </step>
   <step>
    <para>Close and restart &jedit;.</para>
   </step>
   <step>
    <para>Select <menuchoice>
      <guimenu>Plugins</guimenu>
      <guimenu>Plugin Options</guimenu>
     </menuchoice>.</para>
   </step>
   <step>
    <para>In the left navigation pane, select <menuchoice>
      <guimenu>Spell Check</guimenu>
      <guimenu>General</guimenu>
     </menuchoice>.</para>
   </step>
   <step>
    <para>Set <guimenu>Spell-checking engine</guimenu> to
      <guimenu>Aspell</guimenu> and select the <guimenu>Dictionary to
      use</guimenu>, for example <literal>en_US</literal>. </para>
   </step>
   <step>
    <para>If the desired dictionary does not appear in the drop-down list,
     install the respective &aspell; dictionary for the language and
     click <guimenu>Refresh list</guimenu>. </para>
   </step>
   <step>
    <para>In the left navigation pane, switch to <menuchoice>
      <guimenu>Spell Check</guimenu>
      <guimenu>Syntax handling</guimenu>
     </menuchoice>.</para>
   </step>
   <step>
    <para>In the table, activate the <guimenu>markup</guimenu> entry and click
      <guimenu>Edit</guimenu> next to it.</para>
   </step>
   <step>
    <para>In the <guimenu>Token types picker</guimenu>, activate the following
    entries:</para>
    <itemizedlist>
     <listitem>
      <para>NULL</para>
     </listitem>
     <listitem>
      <para>COMMENT1</para>
     </listitem>
     <listitem>
      <para>LITERAL1</para>
     </listitem>
    </itemizedlist>
   </step>
   <step>
    <para>In the left navigation pane, switch to <menuchoice>
      <guimenu>Spell Check</guimenu>
      <guimenu>Aspell Engine</guimenu>
     </menuchoice>.</para>
   </step>
   <step>
    <para>Set the path to the <guimenu>Aspell executable filename</guimenu>.  
    Select <guimenu>Enable markup mode</guimenu>.</para>
   </step>
   <step>
    <para>To use an additional custom &aspell; dictionary, specify the path to the
     custom dictionary in the input field below <guimenu>Additional
     parameters</guimenu>:</para>
    <screen>--extra-dicts=<replaceable>PATH_TO_CUSTOM_DICT</replaceable>
    </screen>
    <para>For example:</para>
    <screen>--extra-dicts=/home/tux/custom_aspell.rws</screen>
   </step>
   <step>
    <para>Confirm your settings in the plugin options dialog with
      <guimenu>OK</guimenu> or <guimenu>Apply</guimenu>.</para>
   </step>
   <step>
    <para>To execute a spell check during editing, select <menuchoice>
      <guimenu>Plugins</guimenu>
      <guimenu>Spell Check</guimenu>
      <guimenu>Highlight misspelled words</guimenu>
     </menuchoice> (or use the keyboard shortcut assigned to that menu
     item).</para>
   </step>
  </procedure>
 </sect1>
 <sect1 id="sec.daps.user.edit.chklink">
  <title>Checking Links to Web Pages</title>
  <para>To make sure that all links in your XML sources are still available
      (and do not give a <literal>404</literal> error or similar), &dapsacr;
      also includes a link checker (based on <literal>checkbot</literal>).
      It searches for the <sgmltag class="attribute">url</sgmltag> attribute in
      <sgmltag>ulink</sgmltag> elements and checks links included there. 
      Use it to create a report of all links that caused some kind of
      warning or error:</para>
  <variablelist>
   <varlistentry>
    <term>Checking Links in a Documentation Project</term>
    <listitem>
     <screen>daps -d <replaceable>PATH_TO_&dc;_FILE</replaceable> chklink</screen>
     <para>Uses the ROOTID defined in the specified &dc; file as starting point. 
     Checks the  <sgmltag>ulink</sgmltag> elements in all files belonging to the documentation
     project. If the documentation project contains XIncludes, the link checker 
     also checks the respective XIncludes. At the end of the check, &dapsacr;
     returns an HTLM file with a list of all links which caused some kind of warning 
     or error. Open the resulting <filename>*checkbot-localhost.html</filename>
     file in a browser.</para>
     <figure>
      <title>Example Output of <command>daps chklink</command>
      </title>
      <mediaobject>
       <imageobject role="fo">
        <imagedata fileref="daps_chklink_report.png" width="90%"/>
       </imageobject>
       <imageobject role="html">
        <imagedata fileref="daps_chklink_report.png" width="80%"/>
       </imageobject>
      </mediaobject>
     </figure>
     <para>If your &dc; file references a documentation <sgmltag>set</sgmltag>, 
     you probably do not want to check all files belonging to the set. You can 
     restrict the check to parts of the set, such as a <sgmltag>book</sgmltag>, 
     <sgmltag>article</sgmltag>, <sgmltag>glossary</sgmltag>, 
     <sgmltag>appendix</sgmltag>, <sgmltag>part</sgmltag>, or 
     <sgmltag>chapter</sgmltag> element. To do so, specify the ID of the
     respective element with the <option>--rootid</option> option:</para>
     <screen>daps -d <replaceable>PATH_TO_&dc;_FILE</replaceable> chklink --rootid=<replaceable>ID</replaceable>
     </screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Checking Links in One or Multiple XML Files</term>
    <listitem>
     <screen>daps -d <replaceable>PATH_TO_&dc;_FILE</replaceable> chklink --file=xml/<replaceable>filename</replaceable>.xml</screen>
     <para>
      <remark>taroth 2012-05-29: check: individual files only? or also multiple files?</remark>
     Checks the  <sgmltag>ulink</sgmltag> elements in 
     <filename><replaceable>filename.xml</replaceable>
      </filename>. At the end of 
     the check, &dapsacr; returns an HTLM file with a list of all links which 
     caused some kind of warning or error. Open the resulting
     <filename>*checkbot-localhost.html</filename> file in a browser.</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>
 <sect1 id="sec.daps.user.edit.variants">
  <title>Preparing Document Variants</title>
  <para>Similar products often share a considerable amount of features and
  differ in details only. It is therefore convenient to apply the same approach 
  to the documentation of similar products or product families: Share most of the
  XML source code and only differentiate text snippets according to products 
  where necessary.
  </para>
  <para>For easily managing and creating documentation variants from the same
  pool of XML sources, you can use of the following features that are supported 
  by &dapsacr;:</para>
  <variablelist>
   <varlistentry>
    <term>Profiling (<quote>Conditional Text</quote>)
    </term>
    <listitem>
    &db-profiling;
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Entities for Dynamic Product Names and Numbers</term>
    <listitem>
     <para>&daps-product-entities;</para>
    </listitem>
   </varlistentry>
  </variablelist>
  <sect2 id="sec.daps.user.edit.variants.profiling">
   <title>Profiling Attributes</title>
   <para>DocBook offers profiling attributes for various purposes. &dapsacr; currently supports
    the following attributes:</para> &daps-profiling-attributes; <para>Profiling attributes can
    be used on a large number of elements &mdash;from high-level elements like
     <sgmltag>book</sgmltag> or <sgmltag>chapter</sgmltag> down to low-level elements like
     <sgmltag>para</sgmltag>. With the <sgmltag>phrase</sgmltag> element, you can even profile
    inline elements, like one sentence within a paragraph. </para>
   <para>Based on the conditions that you want to apply, select one or more profiling attributes.
    You are free in defining the attributes values, but they must be used consistently in all files
    belonging to a documentation project.</para>
   <para>Any content that is valid for <emphasis>all</emphasis> products does
     <emphasis>not</emphasis> need any profiling attributes. The respective content will always be
    included in the output formats generated from the XML sources. Text snippets that only apply to
    a certain condition can be tagged with the respective profiling attribute or attributes. The
    tagged snippets will only be included in the output, if the required condition is
    fulfilled.</para>
   <example id="ex.daps.profiling">
    <title>Example for Profiling Articles Within a Book</title>
    <screen>&lt;?xml version="1.0" encoding="utf-8"?&gt;
[...]    
&lt;book lang="en" id="book.quickstarts"&gt;
 &lt;bookinfo&gt;
  &lt;title&gt;Quick Start Manuals&lt;/title&gt;
  &lt;productname&gt;&amp;productname;&lt;/productname&gt;
  &lt;productnumber&gt;&amp;productnumber;&lt;/productnumber&gt;
  &lt;date&gt;&lt;?dbtimestamp format="B d, Y"?&gt;&lt;/date&gt;
   &lt;xi:include href="common_copyright_gfdl.xml" 
               xmlns:xi="http://www.w3.org/2001/XInclude"/&gt; <co id="co.daps.prof.all"/>
 &lt;/bookinfo&gt;
 &lt;xi:include os="sled;osuse" href="art_kde_quick.xml" 
             xmlns:xi="http://www.w3.org/2001/XInclude"/&gt; <co id="co.daps.prof.sled.osuse"/>
 &lt;xi:include os="sled;osuse" href="art_gnome_quick.xml" 
             xmlns:xi="http://www.w3.org/2001/XInclude" /&gt; <xref linkend="co.daps.prof.sled.osuse" xrefstyle="select:label nopage"/>
 &lt;xi:include os="sled" href="art_sled_install_quick.xml" 
             xmlns:xi="http://www.w3.org/2001/XInclude"  /&gt; <co id="co.daps.prof.sled"/>
 &lt;xi:include os="sles" href="art_sles_install_quick.xml" 
             xmlns:xi="http://www.w3.org/2001/XInclude" /&gt;<co id="co.daps.prof.sles"/>
 &lt;xi:include os="sled;sles;osuse" href="art_apparmor_quick.xml" 
             xmlns:xi="http://www.w3.org/2001/XInclude"/&gt; <co id="co.daps.prof.sled.sles.osuse"/> 
 &lt;xi:include os="sled;sles" href="art_audit_quick.xml"  
             xmlns:xi="http://www.w3.org/2001/XInclude" /&gt; <co id="co.daps.prof.sled.sles"/>
 &lt;xi:include os="sled" href="art_libreoffice_quick.xml" 
             xmlns:xi="http://www.w3.org/2001/XInclude" /&gt; <xref linkend="co.daps.prof.sled" xrefstyle="select:label nopage"/>
 &lt;xi:include os="sles" href="art_lxc_quick.xml" 
             xmlns:xi="http://www.w3.org/2001/XInclude" /&gt; <xref linkend="co.daps.prof.sles" xrefstyle="select:label nopage"/>
&lt;/book&gt;</screen>
   </example>
   <para>The example above shows a book named <citetitle>Quick Start Manuals</citetitle> that
    contains a number of articles, for example <citetitle>KDE Quick Start</citetitle> and
     <citetitle>LXC Quick Start</citetitle>. The <literal>os</literal> attribute is used for
    profiling according to products. The attribute values refer to the following:</para>
   <itemizedlist>
    <listitem>
     <para>sled: &sled;</para>
    </listitem>
    <listitem>
     <para>sles: &sles;</para>
    </listitem>
    <listitem>
     <para>osuse: &osuse;</para>
    </listitem>
   </itemizedlist>
   <calloutlist>
    <callout arearefs="co.daps.prof.all">
     <para>This XInclude does not contain any profiling attributes, meaning the contents of this
      file will always be included in the output.</para>
    </callout>
    <callout arearefs="co.daps.prof.sled.osuse">
     <para>This XInclude is profiled for both &sled; and &osuse;: If the book
       <citetitle>GNOME Quick Start</citetitle> is generated for &sled; or &osuse;, the
      articles <citetitle>KDE Quick Start</citetitle> and <citetitle>GNOME Quick Start</citetitle>
      should be included in the book. If the same book is generated for &sles;, this articles
      should not appear.</para>
    </callout>
    <callout arearefs="co.daps.prof.sled">
     <para>This XInclude is profiled for &sled;. This means if the book <citetitle>Quick Start
       Manuals</citetitle> is generated for &sled;, the articles <citetitle>SLED Installation
       Quick Start</citetitle> and <citetitle>LibreOffice Quick Start</citetitle> will be included.
      For &osuse; and &sles;, this articles will be excluded from the book.</para>
    </callout>
    <callout arearefs="co.daps.prof.sles">
     <para>This XInclude is profiled for &sles;. This means if the book <citetitle>Quick Start
       Manuals</citetitle> is generated for &sles;, the articles <citetitle>SLES Installation
       Quick Start</citetitle> and <citetitle>LXC Quick Start</citetitle> will be included. For
      &osuse; and &sled;, this articles will be excluded from the book.</para>
    </callout>
    <callout arearefs="co.daps.prof.sled.sles.osuse">
     <para>This XInclude is profiled for all three products: &sles;, &sled;, and
      &osuse;, meaning the article <citetitle>AppArmor Quick Start</citetitle> will be included
      in the book <citetitle>Quick Start Manuals</citetitle> for all of these products. </para>
    </callout>
    <callout arearefs="co.daps.prof.sled.sles">
     <para>This XInclude is profiled for both &sled; and &sles;. This means if the book
       <citetitle>Quick Start Manuals</citetitle> is generated for &sles; or &sled;, the
      article <citetitle>Audit Quick Start</citetitle> will be included. For &osuse;, this
      article will be excluded from the book.</para>
    </callout>
   </calloutlist>
   
   <example id="ex.daps.profiling.inline">
    <title>Example for Profiling Inline Elements</title>
   <screen></screen>
   </example>
   <para>For more details about using profiling attributes, refer to <ulink
     url="http://www.sagehill.net/docbookxsl/Profiling.html"/>.</para>
   <para>If using profiling attributes in your XML sources, you need to define which of them should
    be interpreted by &dapsacr; during generation of output. Set the respective
     <parameter>PROF*</parameter> parameters in the &dc; file of your documentation project and
    define which values should be interpreted during generation of output format. <remark>taroth
     2012-05-30: todo - add example</remark>
   </para>
   <para>In order for the profiling process to take effect, the following line must be included in
    the Main file of your documentation project:</para>
   <screen>href="urn:x-daps:xslt:profiling:docbook45-profile.xsl" type="text/xml"</screen>
   <para>Without that line, any profiling parameters in the &dc; file will be ignored during
    generation of the output.</para>
  </sect2>
  <sect2 id="sec.daps.user.edit.variants.productentities">
   <title>Entities for Dynamic Product Names and Numbers</title>
   <para>
    <remark>taroth 2012-05-30: FIXME</remark>
   </para>
  </sect2>
 </sect1>

 <sect1 id="sec.daps.user.edit.validate">
  <title>Validating Your XML Sources</title>

  <para>
   Validating XML files within in a book or set often exceeds validation of
   the current XML file, as links (<sgmltag>xref</sgmltag> elements) or
   XIncludes need to be resolved, too. If you use conditional text
   (<literal>profiling</literal>) in your XML sources (for creating
   variants), your XML editor cannot check validity of your XML files.
   However, &dapsacr; can handle all those cases due to the built-in xmllint
   validator.
  </para>

  <procedure>
   <title>Validating XML Files</title>
   <para>
    To validate all files that belong to your documentation project,
    &dapsacr; only needs to know which &dclong; file to use. If you have
    specified a value for <parameter>DOCCONF_DEFAULT</parameter> in
    &dapsconf-user; or if your documentation directory contains only one
    &dc; file, &dapsacr; automatically uses the corresponding &dc; file.
    Otherwise, specify the path to the &dc; file with the
    <option>-d</option> option as described below.
   </para>
   <para>
    By default, <sgmltag>remark</sgmltag> elements and XML comments are
    ignored during validation. However, if you intend to create a (draft)
    output including remarks or comments, you need to include them for
    validation by specifying the respective &dapsacr; option.
   </para>
   <step>
    <para>
     To validate all XML files in your book, article or set, enter:
    </para>
    <screen>daps -d <replaceable>PATH_TO_DC_FILE</replaceable> validate </screen>
    <para>
     If the XML files are not valid, &dapsacr; will return the parser
     errors. They include information about the type of error, the
     respective file name and the line number where the error occurred. In
     addition, &dapsacr; shows the path to the profiled XML sources and the
     total number of errors.
    </para>
    <para>
     If validation was successful, &dapsacr; returns: <literal>All files are
     valid.</literal>
    </para>
   </step>
   <step>
    <para>
     To validate your files including remarks, enter:
    </para>
    <screen>daps -d <replaceable>PATH_TO_DC_FILE</replaceable> validate --remarks</screen>
   </step>
   <step>
    <para>
     To validate your files including XML comments, enter:
    </para>
    <screen>daps -d <replaceable>PATH_TO_DC_FILE</replaceable> validate -comments</screen>
   </step>
  </procedure>

  <example>
   <title>Parser Output For Validation Errors</title>
   <screen>daps_user_concept.xml:60: element xref: validity error : IDREF attribute linkend references an unknown ID "itl.daps.user.inst.other.req"
Document /local/svn/daps-svn/daps/doc/build/.profiled/x86-amd64-em64t_osuse_/MAIN.DAPS.xml does not validate
make: *** [validate] Error 3
</screen>
  </example>
 </sect1>

</chapter>
