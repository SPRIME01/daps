#
# Functions for ../bin/daps
#
# Copyright (C) 2011 Frank Sundermeyer <fs@suse.de>, openSUSE.org
# Authors: Frank Sundermeyer <fs@suse.de>
#
#
# TODO:
#function bookinit () {
#}

# TODO:
# make COMMENTS, DRAFT, and REMARKS options that can be set (--draft=1), so the
# config file values can also be overwritten, when the feature is turned on
# in the config file
# In order to do so, it would be good to have a generic function that can check
# and set the correct values rather than duplicating 


# ----------------------------------------------------------------------------
# Core functions
#
# The most important stuff comes first
#

# ---------
# Calling make and writing a log file 
#

function setup_builddir {
    # Create the log directory and a link to the ENV-file in R_DIR
    # (R_DIR and LOG_DIR are set in bin/daps) 

    mkdir -p $LOG_DIR || exit_on_error "Cannot create $LOG_DIR"

    if [[ ! -f ${R_DIR}/$ENVFILE ]]; then
        ln -sf ${BASE_DIR}/$ENVFILE ${R_DIR}/$ENVFILE || ccecho "warn" "Warning: Cannot create link to $ENVFILE in $R_DIR"
    fi

    # There should only be one ENVFILE in $R_DIR
    #
    ENV_COUNT=$(find -L $R_DIR -maxdepth 1 -name "${CONF_PREFIX}*" -type f | wc -l)
    if [[ $ENV_COUNT -gt 1 ]]; then
        ccecho "warn" "$R_DIR contains more than one ENVFILE"
    fi
}
    
function call_make () {
    local TARGET LOGFILE MCMD

    # first argument passed to the function is the subcommand
    # in some cases, additional arguments are passed to this
    # function - they remain i $@
    #
    TARGET=$1
    shift

    setup_builddir
    
    MCMD="$MAKECMD -f $DTDROOT/make/common.mk $TARGET $@"
    
    LOGFILE="${LOG_DIR}/make_${TARGET}.log"
    date &> $LOGFILE

    if [[ 1 = $VERBOSE ]]; then
        echo "
---------------
   BASE_DIR: $BASE_DIR
  BUILD_DIR: $BUILD_DIR
    ENVFILE: $ENVFILE
    DTDROOT: $DTDROOT
       BOOK: $BOOK
        FOP: $FOPTYPE
    MAKECMD: $MAKECMD
    STYLEFO: $STYLEFO
XML_CATALOG: $XML_CATALOG_FILES
---------------
" | tee -a $LOGFILE
        eval "$MCMD 2>&1 | tee -a $LOGFILE"
    else
        eval "$MCMD >> $LOGFILE 2>&1"
        if [[ 0 = $? ]]; then
	   # make command successful
	    tail -n 1 $LOGFILE
        else
	    cat $LOGFILE
        fi
    fi
}

function call_make_nolog () {

    # TODO: debug and verbose
    
    # do not write a logfile, to be used whenever writing a logfile
    # is not necessary (e.g. for targets clean*)
    local TARGET MCMD
    TARGET=$1

    setup_builddir
    
    MCMD="$MAKECMD -f $DTDROOT/make/common.mk $TARGET $@"
    if [[ 1 = $PRETTY_FILELIST ]]; then
        eval "$MCMD 2>/dev/null" | sed 's/ /\n/g' | sort
    else
        eval "$MCMD 2>/dev/null"
    fi
}

function wrong_parameter () {
    local TARGET PARAM
    TARGET=$1
    echo "Type '$ME $TARGET help' to get a list of valid parameters"
    exit 1;
}

function init_wd () {
    # Initialize a working directory to get started with daps
    #

    test -z "$BASE_DIR" && exit_on_error "You must specify BASE_DIR when calling $ME init"
    
    SARGS=$(getopt -o h -l help,name:,rootelement: -n $0 -- "${SCMD_ARGS[@]}")
    if [[ 1 = $? ]]; then
        wrong_parameter "$TARGET"
    fi
    eval set -- "$SARGS"
    while true ; do
	case "$1" in
            -h|--help)
                help_scmd_head "Create a working environment for a book/article"
                help_dirname
                help_rootelement
                echo
		exit 0
		;;
            --dirname)
                DIR_NAME="$2"
                shift 2
                ;;
	    --rootelement)
                if [[ article = $2 || book = $2 ]]; then
                    ROOTELEMENT="$2"
                else
                    exit_on_error "ROOTELEMENT must be either article or book"
                fi
		shift 2
		;;
            --) shift ; break ;;
            *) wrong_parameter "$TARGET $1" ;;
	esac
    done

    # default when not set is book
    test -z $ROOTELEMENT && ROOTELEMENT=book
    
    if [[ -n $PDFNAME ]]; then
        BOOK="$PDFNAME"
    else
        BOOK="${ENVFILE#*${CONF_PREFIX}}"
    fi
    
    if [[ -z $DIR_NAME ]]; then
        DIR_NAME=$BOOK
    fi
    
    BASE_DIR="${BASE_DIR}/$BOOK"
    R_DIR="${BASE_DIR}/build/${BOOK}"
    LOG_DIR="${R_DIR}/log"
    
    # Create BASE_DIR and needed subdirectories
    mkdir -p $BASE_DIR
    mkdir -p ${BASE_DIR}/images/src/{dia,fig,png,svg} ${BASE_DIR}/xml

    # copy the templates
    #
    # ENV file
    cp ${LIB_DIR}/templates/ENV-file.template ${BASE_DIR}/$ENVFILE && \
        sed -i s/§§MAIN§§/MAIN-$BOOK.xml/g ${BASE_DIR}/$ENVFILE
    # MAIN
    cp ${LIB_DIR}/templates/MAIN.$ROOTELEMENT.template ${BASE_DIR}/xml/MAIN-${BOOK}.xml
    # graphics
    cp ${LIB_DIR}/templates/example{1,2}.png ${BASE_DIR}/images/src/png/
  
    setup_builddir
    if [[ 1 = $VERBOSE ]]; then
        ccecho "result" "Successfully created a working environment at"
    fi
    ccecho "result" "${BASE_DIR}"
    exit 1;
}


# ----------------------------------------------------------------------------
# Functions processing existing make targets 
#

function build_pdfs () {
    # targets force, pdf*, color-pdf
    #
    local TARGET=$1
    shift
    # command line args
    SARGS=$(getopt -o cdhr -l comments,draft,fop:,help,name:,remarks,rootid: -n $0 -- "${SCMD_ARGS[@]}")
    if [[ 1 = $? ]]; then
        wrong_parameter "$TARGET"
    fi
    eval set -- "$SARGS"
    while true ; do
	case "$1" in
	    -c|--comments)
		export COMMENTS=1
		shift
		;;
	    -d|--draft)
		export DRAFT="yes"
		shift
		;;
	    --fop)
                if [[ xep = $2 || fop = $2 ]]; then
                    export FOPTYPE="$2"
                    export FOP="${LIB_DIR}/daps-$2"
                else
		    exit_on_error "Wrong parameter for $1: must be \"xep\" or \"fop\"!"
                fi
		shift 2
		;;
            -h|--help)
                help_scmd_head "Build a $TARGET book"
                help_comments
                help_draft
                help_fop
                help_help
                help_name
                help_remarks
                help_rootid
                echo
		exit 0
		;;
            --name)
                export PDFNAME="$2"
                export BOOK="$PDFNAME"
                shift 2
                ;;
            -r|--remarks)
		export REMARKS=1
		shift
		;;
	    --rootid)
		export ROOTID="$2"
		shift 2
		;;
            --) shift ; break ;;
#            *) exit_on_error "Internal error!" ;;
            *) wrong_parameter "$TARGET $1" ;;
	esac
    done

    call_make "$TARGET" "$@"
    
}

function build_html_jsp () {
    # targets html*, jsp
    #
    local TARGET=$1
    shift
    # command line args
    SARGS=$(getopt -o cdhmr -l comments,draft,help,name:,meta,remarks,rootid: -n $0 -- "${SCMD_ARGS[@]}")
    if [[ 1 = $? ]]; then
        wrong_parameter "$TARGET"
    fi
    eval set -- "$SARGS"
    while true ; do
	case "$1" in
	    -c|--comments)
		export COMMENTS=1
		shift
		;;
	    -d|--draft)
		export DRAFT="yes"
		shift
		;;
            -h|--help)
                help_scmd_head "Build a $TARGET book"
                help_comments
                help_draft
                help_help
                help_meta
                help_name
                help_remarks
                help_rootid
                echo
                exit 0
		;;
            -m|--meta)
                export USEMETA=1
                # Implies draft and remarks mode
                export DRAFT="yes"
                export REMARKS=1
                shift
                ;;
            --name)
                export PDFNAME="$2"
                export BOOK="$PDFNAME"
                shift 2
                ;;
            -r|--remarks)
		export REMARKS=1
		shift
		;;
	    --rootid)
		export ROOTID="$2"
		shift 2
		;;
            --) shift ; break ;;
            *) exit_on_error "Internal error!" ;;
	esac
    done

    call_make "$TARGET" "$@"
    
}

function build_epub () {
    # taget: epub
    local TARGET=$1
    shift
    # command line args
    SARGS=$(getopt -o hr -l help,name:,remarks,rootid: -n $0 -- "${SCMD_ARGS[@]}")
    if [[ 1 = $? ]]; then
        wrong_parameter "$TARGET"
    fi
    eval set -- "$SARGS"
    while true ; do
	case "$1" in
            -h|--help)
                help_scmd_head "Build an $TARGET book"
                help_help
                help_name
                help_rootid
                echo
                exit 0
		;;
            --name)
                export PDFNAME="$2"
                export BOOK="$PDFNAME"
                shift 2
                ;;
	    --rootid)
		export ROOTID="$2"
		shift 2
		;;
            -r|--remarks)
		export REMARKS=1
		shift
		;;
            --) shift ; break ;;
            *) exit_on_error "Internal error!" ;;
	esac
    done

    call_make "$TARGET" "$@"
    
}

function build_locdrop () {
    # target: locdrop
    local TARGET=$1
    shift
    # command line args
    SARGS=$(getopt -o h -l help,name:,rootid: -n $0 -- "${SCMD_ARGS[@]}")
    if [[ 1 = $? ]]; then
        wrong_parameter "$TARGET"
    fi
    eval set -- "$SARGS"
    while true ; do
	case "$1" in
            -h|--help)
                help_scmd_head "Provide everything that is needed to translate a set"
                help_help
                help_name
                help_nopdf
                help_rootid
                echo
                exit 0
		;;
            --name)
                export PDFNAME="$2"
                export BOOK="$PDFNAME"
                shift 2
                ;;
            -n|--nopdf)
                export NOPDF="1"
                shift
                ;;
	    --rootid)
		export ROOTID="$2"
		shift 2
		;;
            --) shift ; break ;;
            *) exit_on_error "Internal error!" ;;
	esac
    done

    call_make "$TARGET" "$@"
}

function profile_first () {
    # targets: dist-graphics*, dist-html, dist-jsp, missinggraphics,
    # projectgraphics, remaininggraphics, showvariable
    #
    # some targets (such as projectgraphics and various dist and packaging
    # targets) require an up-tp-date .profiled/*
    # Therefore we call make profile first and then call make a second time
    # with the real target
    #
    local TARGET=$1
    shift
    call_make "profile" "$@"
    call_make "$TARGET" "$@"
}

function build_generic () {
    local TARGET=$1
    shift
    # command line args
    SARGS=$(getopt -o h -l help,name:,rootid: -n $0 -- "${SCMD_ARGS[@]}")
    if [[ 1 = $? ]]; then
        wrong_parameter "$TARGET"
    fi
    eval set -- "$SARGS"
    while true ; do
	case "$1" in
            -h|--help)
                help_scmd_head "Build a $TARGET book"
                help_help
                help_name
                help_rootid
                echo
                exit 0
		;;
            --name)
                export PDFNAME="$2"
                export BOOK="$PDFNAME"
                shift 2
                ;;
	    --rootid)
		export ROOTID="$2"
		shift 2
		;;
            --) shift ; break ;;
            *) exit_on_error "Internal error!" ;;
	esac
    done

    call_make "$TARGET" "$@"
    
}

function filelists () {
    local TARGET=$1
    shift
    # command line args
    SARGS=$(getopt -o hp -l help,pretty -n $0 -- "${SCMD_ARGS[@]}")
    if [[ 1 = $? ]]; then
        wrong_parameter "$TARGET"
    fi
    eval set -- "$SARGS"
    while true ; do
	case "$1" in
            -h|--help)
                help_scmd_head "Print a list of $TARGET"
                help_help
                help_pretty
                echo
                exit 0
		;;
            -p|--pretty)
                if [[ 1 = $VERBOSE ]]; then
                    ccecho "warn" "Pretty printing is automatically disabled in verbose/debug mode"
                else
                    PRETTY_FILELIST=1
                fi
                shift
                ;;
            --) shift ; break ;;
            *) exit_on_error "Internal error!" ;;
	esac
    done
#    if [[ $TARGET =~ graphics ]]; then
#        call_make_nolog "profile" "$@"
#    fi
    call_make_nolog "$TARGET" "$@"
}

function packaging () {
    local TARGET=$1
    shift
    # command line args
    if [[ package-pdf = $TARGET ]]; then
        SARGS=$(getopt -o h -l fop:,help,name:,rootid: -n $0 -- "${SCMD_ARGS[@]}")
    elif [[ package-src = $TARGET ]]; then
        SARGS=$(getopt -o h -l extra-files:,help,name:,rootid: -n $0 -- "${SCMD_ARGS[@]}")
    else
        SARGS=$(getopt -o h -l help,name:,rootid: -n $0 -- "${SCMD_ARGS[@]}")
    fi
    if [[ 1 = $? ]]; then
        wrong_parameter "$TARGET"
    fi
    eval set -- "$SARGS"
    while true ; do
	case "$1" in
            --extra-files)
                for FILE in $2; do
                    test -f $FILE || exit_on_error "Cannot find extra file $FILE"
                done
                export EXTRA_FILES=$2
                shift 2
                ;;
            --fop)
                if [[ $2 = xep || $2 = fop ]]; then
                    export FOPTYPE="$2"
                    export FOP="${LIB_DIR}/daps-$2"
                else
		    exit_on_error "Wrong parameter for $1: must be \"xep\" or \"fop\"!"
                fi
		shift 2
		;;
            -h|--help)
                help_scmd_head "Build a $TARGET book"
                if [[ package-pdf = $TARGET ]]; then
                    help_fop
                elif [[ package-src = $TARGET ]]; then
                    help_extrafiles
                fi
                help_help
                help_name
                help_rootid
                echo
                exit 0
		;;
            --name)
                export PDFNAME="$2"
                export BOOK="$PDFNAME"
                shift 2
                ;;
	    --rootid)
		export ROOTID="$2"
		shift 2
		;;
            --) shift ; break ;;
            *) exit_on_error "Internal error!" ;;
	esac
    done

    call_make "$TARGET" "$@"
    
}

 


# ----------------------------------------------------------------------------
# Help functions
#
# There are a lot of options, several functions have in common. I do
# not want to write the same text again and again, so I am providing
# extra functions for all help texts that appear more than once.

function help_scmd_head () {
    echo "
$ME [--global-options] $TARGET [options]

$1

  Command options:"
}

function help_comments () {
    echo "        --comments, -c            Include XML comments in profiled sources
                                  Default: off"  
}
function help_dirname () {
    echo "    --dirname=DIR                 Directory names to be created in BASE_DIR
                              Default: generated by stripping 'ENV-' from the
                              ENV filename"
}
function help_draft () {
    echo "    --draft, -d               Add a 'DRAFT' watermark to all pages of the book
                              Default: off" 
}
function help_extrafiles () {
    echo "    --extra-files=FILES       Specify a space separated list of additional files to
                              be added to the source tarball. Paths must be
                              relative to BASE_DIR"
}
function help_fop () {
    echo "    --fop=FORMATTER           Specify the PDF formatter to be used. Currently
                              'xep' or 'fop' are supported.
                              Default: 'xep'"
}
function help_help () {
    echo "    --help, -h                Print this help text"
}
function help_name () {
    echo "    --name=BOOKNAME           File- and directory names for generated content
                              are derived from BOOKNAME.
                              Default: generated by stripping 'ENV-' from the
                              ENV filename"
}
function no_pdf () {
    echo "    --nopdf, -n               Deactivates creating the color-pdf. Useful when
                              \"locdropping\" a complete set where you
                              want to deliver separate PDFs for each book
                              rather than one huge PDF for the whole set.
                              Default: off"
}
function help_meta () {
    echo "    --meta, -m                If set, prints additional status information
                              (filename, maintainer and status) for each file.
                              Implies draft mode.
                              Default: off"
}
function help_pretty () {
    echo "    --pretty, -p              Pretty print file lists (one filename per line)"
}
function help_remarks () {
    echo "    --remarks, -r             Include remarks (<remark>...</remark>) in book
                              Default: off"  
}
function help_rootelement () {
    echo "    --rootelement=ELEMENT     Specify a ROOTELEMENT for your main DocBook XML file
                              must be one either article or book.
                              Default: book"
}
function help_rootid () {
    echo "    --rootid=ID               Specify a ROOTID to build only parts of a book
                              (parts or chapters). Default: Usually set
                              in the ENV-file; if not set the complete set
                              defined in $MAIN will be built"
}
