#
# Functions for ../bin/daps
#
# Copyright (C) 2011 Frank Sundermeyer <fs@suse.de>, openSUSE.org
# Authors: Frank Sundermeyer <fs@suse.de>
#
#

# TODO:
# make COMMENTS, DRAFT, and REMARKS options that can be set (--draft=1), so the
# config file values can also be overwritten, when the feature is turned on
# in the config file
# In order to do so, it would be good to have a generic function that can check
# and set the correct values rather than duplicating 


# ----------------------------------------------------------------------------
# Core functions
#
# The most important stuff comes first
#

# ---------
# Calling make and writing a log file 
#

function setup_builddir {
    # Create the log directory and a link to the ENV-file in R_DIR
    # (R_DIR and LOG_DIR are set in bin/daps) 

    mkdir -p $LOG_DIR || exit_on_error "Cannot create $LOG_DIR"

    if [[ ! -f ${R_DIR}/$ENVFILE ]]; then
        ln -sf ${BASE_DIR}/$ENVFILE ${R_DIR}/$ENVFILE || ccecho "warn" "Warning: Cannot create link to $ENVFILE in $R_DIR"
    fi

    # There should only be one ENVFILE in $R_DIR
    #
    ENV_COUNT=$(find -L $R_DIR -maxdepth 1 -name "${CONF_PREFIX}*" -type f | wc -l)
    if [[ $ENV_COUNT -gt 1 ]]; then
        ccecho "warn" "$R_DIR contains more than one ENVFILE"
    fi
}

function format_options () {
# COMMENTS must be set to 1|0
if [[ yes = $COMMENTS || 1 = $COMMENTS ]]; then
    COMMENTS=1
elif [[ no = $COMMENTS || 0 = $COMMENTS || -z $COMMENTS ]]; then
    COMMENTS=0
    unset COMMENT_STR # only needed when comment is set
else
    exit_on_error "Wrong value for COMMENTS. Must be \"yes\" or \"no\""
fi

# DRAFT must be set to yes|no
if [[ yes = $DRAFT || 1 = $DRAFT ]]; then
    DRAFT="yes"
elif [[ no = $DRAFT || 0 = $DRAFT || -z $DRAFT ]]; then
    DRAFT="no"
    unset DRAFT_STR # only needed when comment is set
else
    exit_on_error "Wrong value for DRAFT. Must be \"yes\" or \"no\""
fi

# REMARKS must be set to 1|0
if [[ yes = $REMARKS || 1 = $REMARKS ]]; then
    REMARKS="1"
elif [[ no = $REMARKS || 0 = $REMARKS || -z $REMARKS ]]; then
    REMARKS="0"
    unset REMARK_STR # only needed when comment is set
else
    exit_on_error "Wrong value for REMARKS. Must be \"yes\" or \"no\""
fi

# USEMETA must be set to 1|0
if [[ yes = $USEMETA || 1 = $USEMETA ]]; then
    USEMETA=1
elif [[ no = $USEMETA || 0 = $USEMETA || -z $USEMETA ]]; then
    USEMETA=0
else
    exit_on_error "Wrong value for USEMETA. Must be \"yes\" or \"no\""
fi

export COMMENTS DRAFT REMARKS USEMETA 

}

function call_make () {
    local TARGET LOGFILE MCMD

    # first argument passed to the function is the subcommand
    # in some cases, additional arguments are passed to this
    # function - they remain i $@
    #
    TARGET=$1
    shift

    setup_builddir

    # export comments, remarks, draft, usemeta
    format_options

    MCMD="$MAKECMD -f $DTDROOT/make/common.mk $TARGET $@"
    
    LOGFILE="${LOG_DIR}/make_${TARGET}.log"
    date &> $LOGFILE

    if [[ 1 = $VERBOSE ]]; then
        echo "
---------------
   BASE_DIR: $BASE_DIR
  BUILD_DIR: $BUILD_DIR
    ENVFILE: $ENVFILE
    DTDROOT: $DTDROOT
       BOOK: $BOOK
        FOP: $FOPTYPE
    MAKECMD: $MAKECMD
    STYLEFO: $STYLEFO
XML_CATALOG: $XML_CATALOG_FILES
---------------
" | tee -a $LOGFILE
        eval "$MCMD 2>&1 | tee -a $LOGFILE"
    else
        eval "$MCMD >> $LOGFILE 2>&1"
        if [[ 0 = $? ]]; then
	   # make command successful
	    tail -n 1 $LOGFILE
        else
            # an error occured
            #
            # show complete logfile except the first line containing the
            # date
            # tail -n +2 does the trick
            #
	    tail -n +2 $LOGFILE
            exit 1
        fi
    fi
}

function call_make_nolog () {

    # TODO: debug and verbose
    
    # do not write a logfile, to be used whenever writing a logfile
    # is not necessary (e.g. for targets clean*)
    local TARGET MCMD
    TARGET=$1

    # command line args
    SARGS=$(getopt -o h -l help,name:,rootid: -n $0 -- "$@")
    if [[ 1 = $? ]]; then
        wrong_parameter "$TARGET"
    fi
    eval set -- "$SARGS"
    while true ; do
	case "$1" in
            -h|--help)
                help_nohelp
                exit
                ;;
            --) shift ; break ;;
            *) wrong_parameter "$TARGET $1" ;;
        esac
    done
    
    setup_builddir

    # export comments, remarks, draft, usemeta
    format_options
    
    MCMD="$MAKECMD -f $DTDROOT/make/common.mk $TARGET $@"
    if [[ 1 = $PRETTY_FILELIST ]]; then
        eval "$MCMD" | sed 's/ /\n/g' | sort
    else
        eval "$MCMD"
    fi
}

function wrong_parameter () {
    local TARGET=$1
    echo "Type '$ME $TARGET help' to get a list of valid parameters"
    exit 1;
}


function init_wd () {
    # Initialize a working directory to get started with daps
    #
   
    SARGS=$(getopt -o h -l help,name:,rootelement: -n $0 -- "$@")
    if [[ 1 = $? ]]; then
        wrong_parameter "$TARGET"
    fi
    eval set -- "$SARGS"
    while true ; do
	case "$1" in
            -h|--help)
                echo "
daps --envfile=<ENVFILE> --basedir=<BASEDIR> init [options]

Create a working environment for a book/article. Specifying an ENVFILE and
a BASEDIR is mandatory. <BASEDIR> must exist, init will create a subdirectory.
"
                help_dirname
                help_rootelement
                echo
		exit 0
		;;
            --dirname)
                DIR_NAME="$2"
                shift 2
                ;;
	    --rootelement)
                if [[ article = $2 || book = $2 ]]; then
                    ROOTELEMENT="$2"
                else
                    exit_on_error "ROOTELEMENT must be either article or book"
                fi
		shift 2
		;;
            --) shift ; break ;;
            *) wrong_parameter "$TARGET $1" ;;
	esac
    done

    test -z "$BASE_DIR" && exit_on_error "You must specify BASE_DIR when calling $ME init"
     
    # default when not set is book
    test -z $ROOTELEMENT && ROOTELEMENT=book
    
    if [[ -n $PDFNAME ]]; then
        BOOK="$PDFNAME"
    else
        BOOK="${ENVFILE#*${CONF_PREFIX}}"
    fi
    
    if [[ -z $DIR_NAME ]]; then
        DIR_NAME=$BOOK
    fi
    
    BASE_DIR="${BASE_DIR}/$BOOK"
    R_DIR="${BASE_DIR}/build/${BOOK}"
    LOG_DIR="${R_DIR}/log"
    
    # Create BASE_DIR and needed subdirectories
    mkdir -p $BASE_DIR || exit_on_error "Cannot create $BASE_DIR" 
    mkdir -p ${BASE_DIR}/images/src/{dia,fig,png,svg} ${BASE_DIR}/xml || exit_on_error "Cannot create subdirectories in $BASE_DIR" 

    # copy the templates
    #
    # ENV file
    cp ${LIB_DIR}/templates/ENV-file.template ${BASE_DIR}/$ENVFILE && \
        sed -i s/§§MAIN§§/MAIN-$BOOK.xml/g ${BASE_DIR}/$ENVFILE
    # MAIN
    cp ${LIB_DIR}/templates/MAIN.$ROOTELEMENT.template ${BASE_DIR}/xml/MAIN-${BOOK}.xml
    # graphics
    cp ${LIB_DIR}/templates/example{1,2}.png ${BASE_DIR}/images/src/png/
  
    setup_builddir
    if [[ 1 = $VERBOSE ]]; then
        ccecho "result" "Successfully created a working environment at"
    fi
    ccecho "result" "${BASE_DIR}"
}

function getimages () {
   
    # Gets a list of images from the file specified with -f or --file
    # and outputs them as:
    #  * default:       long list (one file per line)
    #  * --compact:  compact list (single line)
    #  * --viewer=VIEWER: shows images in VIEWER and prints long list to STDOUT
    #
    # the additional option (-m|--modified) will also print the image file's
    # mtime in long lists (this option is ignored with -c|--compact)

    local CMD_IMG_VIEWER COMPACT FILE MOD SHOW
    declare -a IMGLIST
    
    IMAGEDIR="$BASE_DIR/images/src/"

    SARGS=$(getopt -o f:hms -l compact,file:,help,modified,show,viewer: -n $0 -- "$@")
    if [[ 1 = $? ]]; then
        wrong_parameter "$TARGET"
    fi
    eval set -- "$SARGS"
    while true ; do
	case "$1" in
            --compact)
                COMPACT=1
                shift
                ;;
            -f|--file)
                FILE=$(basename $2)
                shift 2
                ;;
            -h|--help)
                help_scmd_head "List or display images from a profiled DocBook XML file"
                help_compact
                help_file
                help_modified
                help_show
                help_viewer
                echo
		exit 0
		;;
            -m|--modified)
                MOD=1
                shift
                ;;
            -s|--show)
                SHOW=1
                shift
                ;;
	    --viewer)
                CMD_IMG_VIEWER=$2
                IMG_VIEWER=$CMD_IMG_VIEWER
		shift 2
		;;
            --) shift ; break ;;
            *) wrong_parameter "$TARGET $1" ;;
	esac
    done

    # IMG_VIEWER may also be set via config file:
    if [[ $SHOW ]]; then
        IMG_VIEWER=$(which $IMG_VIEWER 2>/dev/null)
        if [[ 0 < $? ]]; then
            if [[ $CMD_IMG_VIEWER ]]; then
                exit_on_error "Cannot find VIEWER $CMD_IMG_VIEWER"
            else
              exit_on_error "Cannot find VIEWER $IMG_VIEWER. Please check your config file"
            fi
        fi
    fi

    # get the profiling directory
    # this will automatically do the profiling, too, if needed
    #
    PROFDIR=$(profile_first showvariable VARIABLE=PROFILEDIR) || exit 1

    if [[ ! -f ${PROFDIR}/$FILE ]]; then
        exit_on_error "File $FILE does not exist in profiling directory $PROFDIR\n.You either mistyped the filename or specified an ENVFILE for a book that does\nnot include $FILE"
    fi

    # the xml command produces a list of filenames from the imagedata tags
    # the sed part generates the path to the image
    # awk removes the duplicates wihout the need to sort it
    # and tr removes the newline statements
    declare -a IMGLIST=( $(/usr/bin/xml sel -t -m "//imagedata" -v "concat(@fileref, '&#x0a;')" ${PROFDIR}/$FILE | sed -e "s:\(.*\.\(.*\)\):${IMAGEDIR}\2/\1:g" | awk '!x[$0]++' | tr '\n' ' ') )   

    if [[ $COMPACT ]]; then
        echo -e "${IMGLIST[@]}\n"
    else
        for IMAGE in ${IMGLIST[@]}; do
            if [[ $MOD ]]; then
	        MODIFIED=$(stat -c %y ${IMAGE} | cut -d '.' -f1)
	        echo "${IMAGE} (${MODIFIED})"
            else
	        echo "${IMAGE}"
            fi
        done  | column -t
        if [[ $SHOW ]]; then
            eval "$IMG_VIEWER ${IMGLIST[@]} &"
        fi
    fi 
    
}


# ----------------------------------------------------------------------------
# Functions processing existing make targets 
#

function build_pdfs () {
    # targets force, pdf*, color-pdf
    #
    local TARGET=$1
    shift
    # command line args
    SARGS=$(getopt -o cdhr -l comments,draft,fop:,help,name:,remarks,rootid: -n $0 -- "$@")
    if [[ 1 = $? ]]; then
        wrong_parameter "$TARGET"
    fi
    eval set -- "$SARGS"
    while true ; do
	case "$1" in
	    -c|--comments)
		export COMMENTS=1
		shift
		;;
	    -d|--draft)
		export DRAFT="yes"
		shift
		;;
	    --fop)
                if [[ xep = $2 || fop = $2 ]]; then
                    export FOPTYPE="$2"
                    export FOP="${LIB_DIR}/daps-$2"
                else
		    exit_on_error "Wrong parameter for $1: must be \"xep\" or \"fop\"!"
                fi
		shift 2
		;;
            -h|--help)
                help_scmd_head "Build a $TARGET book"
                help_comments
                help_draft
                help_fop
                help_help
                help_name
                help_remarks
                help_rootid
                echo
		exit 0
		;;
            --name)
                export PDFNAME="$2"
                export BOOK="$PDFNAME"
                shift 2
                ;;
            -r|--remarks)
		export REMARKS=1
		shift
		;;
	    --rootid)
		export ROOTID="$2"
		shift 2
		;;
            --) shift ; break ;;
#            *) exit_on_error "Internal error!" ;;
            *) wrong_parameter "$TARGET $1" ;;
	esac
    done
    
    call_make "$TARGET" "$@"
    
}

function build_html_jsp () {
    # targets html*, jsp
    #
    local TARGET=$1
    shift
    # command line args
    SARGS=$(getopt -o cdhmr -l comments,draft,help,name:,meta,remarks,rootid: -n $0 -- "$@")
    if [[ 1 = $? ]]; then
        wrong_parameter "$TARGET"
    fi
    eval set -- "$SARGS"
    while true ; do
	case "$1" in
	    -c|--comments)
		export COMMENTS=1
		shift
		;;
	    -d|--draft)
		export DRAFT="yes"
		shift
		;;
            -h|--help)
                help_scmd_head "Build a $TARGET book"
                help_comments
                help_draft
                help_help
                help_meta
                help_name
                help_remarks
                help_rootid
                echo
                exit 0
		;;
            -m|--meta)
                export USEMETA=1
                # Implies draft and remarks mode
                export DRAFT="yes"
                export REMARKS=1
                shift
                ;;
            --name)
                export PDFNAME="$2"
                export BOOK="$PDFNAME"
                shift 2
                ;;
            -r|--remarks)
		export REMARKS=1
		shift
		;;
	    --rootid)
		export ROOTID="$2"
		shift 2
		;;
            --) shift ; break ;;
            *) exit_on_error "Internal error!" ;;
	esac
    done

    call_make "$TARGET" "$@"
    
}

function build_epub () {
    # taget: epub
    local TARGET=$1
    shift
    # command line args
    SARGS=$(getopt -o hr -l help,name:,remarks,rootid: -n $0 -- "$@")
    if [[ 1 = $? ]]; then
        wrong_parameter "$TARGET"
    fi
    eval set -- "$SARGS"
    while true ; do
	case "$1" in
            -h|--help)
                help_scmd_head "Build an $TARGET book"
                help_help
                help_name
                help_rootid
                echo
                exit 0
		;;
            --name)
                export PDFNAME="$2"
                export BOOK="$PDFNAME"
                shift 2
                ;;
	    --rootid)
		export ROOTID="$2"
		shift 2
		;;
            -r|--remarks)
		export REMARKS=1
		shift
		;;
            --) shift ; break ;;
            *) exit_on_error "Internal error!" ;;
	esac
    done

    call_make "$TARGET" "$@"
    
}

function build_locdrop () {
    # target: locdrop
    local TARGET=$1
    shift
    # command line args
    SARGS=$(getopt -o h -l help,name:,rootid: -n $0 -- "$@")
    if [[ 1 = $? ]]; then
        wrong_parameter "$TARGET"
    fi
    eval set -- "$SARGS"
    while true ; do
	case "$1" in
            -h|--help)
                help_scmd_head "Provide everything that is needed to translate a set"
                help_help
                help_name
                help_nopdf
                help_rootid
                echo
                exit 0
		;;
            --name)
                export PDFNAME="$2"
                export BOOK="$PDFNAME"
                shift 2
                ;;
            -n|--nopdf)
                export NOPDF="1"
                shift
                ;;
	    --rootid)
		export ROOTID="$2"
		shift 2
		;;
            --) shift ; break ;;
            *) exit_on_error "Internal error!" ;;
	esac
    done

    call_make "$TARGET" "$@"
}

function checklink () {
    # HTTP link checker
    #
    local FILE TARGET
    TARGET=$1
    shift
    # command line args
    SARGS=$(getopt -o f:h -l file:,help,rootid: -n $0 -- "$@")
    if [[ 1 = $? ]]; then
        wrong_parameter "$TARGET"
    fi
    eval set -- "$SARGS"
    while true ; do
	case "$1" in
            -f|--file)
                if [[ -f $2 ]]; then
                    FILE="$2"
                else
                    exit_on_error "File $FILE does not exist"
                fi
                shift 2
                ;;
            -h|--help)
                help_scmd_head "Checks ftp and http(s) links"
                help_file
                help_help
                help_rootid
                echo -e "    NOTES: Options --file (-f) and --rootid exclude one another.\n           Checklink follows xi:includes\n"
		exit 0
		;;
	    --rootid)
		export ROOTID="$2"
		shift 2
		;;
            --) shift ; break ;;
#            *) exit_on_error "Internal error!" ;;
            *) wrong_parameter "$TARGET $1" ;;
	esac
    done

    # You can either specify rootid _or_ file
    if [[ -n $FILE && -n $ROOTID ]]; then
        exit_on_error "Options --file (-f) and --rootid exclude one another.\nPlease specify only one of these options" 
    fi

    ROOTID=$(/usr/bin/xml sel -t -v '/*/@id' $FILE) || exit_on_error "Cannot get a rootid from file $FILE"
    
    call_make "$TARGET" "$@"
    
}

function coments_remarks () {
    # target profiledir is depending in remarks and comments
    #
    local TARGET=$1
    shift
    # command line args
    SARGS=$(getopt -o chr -l comments,help,remarks -n $0 -- "$@")
    if [[ 1 = $? ]]; then
        wrong_parameter "$TARGET"
    fi
    eval set -- "$SARGS"
    while true ; do
	case "$1" in
	    -c|--comments)
		export COMMENTS=1
		shift
		;;
            -h|--help)
                if [[ profiledir = $TARGET ]]; then
                    help_scmd_head "Print the profiling directory"
                elif [[ validate = $TARGET ]]; then
                    help_scmd_head "Validate profiled sources"
                fi
                help_comments
                help_remarks
                echo
		exit 0
		;;
            -r|--remarks)
		export REMARKS=1
		shift
		;;
            --) shift ; break ;;
#            *) exit_on_error "Internal error!" ;;
            *) wrong_parameter "$TARGET $1" ;;
	esac
    done

    call_make_nolog "$TARGET" "$@"
    
}

function profile_first () {
    # targets: dist-graphics*, dist-html, dist-jsp, missinggraphics,
    # projectgraphics, remaininggraphics, showvariable
    #
    # some targets (such as projectgraphics and various dist and packaging
    # targets) require an up-tp-date .profiled/*
    # Therefore we call make profile first and then call make a second time
    # with the real target
    #
    local TARGET=$1
    shift

    # command line args
    SARGS=$(getopt -o h -l help,name:,rootid: -n $0 -- "$@")
    if [[ 1 = $? ]]; then
        wrong_parameter "$TARGET"
    fi
    eval set -- "$SARGS"
    while true ; do
	case "$1" in
            -h|--help)
                help_nohelp
                exit
                ;;
        esac
    done
    
    call_make_nolog "profile" "$@" || exit 1
    call_make_nolog "$TARGET" "$@"
}

function build_generic () {
    local TARGET=$1
    shift
    # command line args
    SARGS=$(getopt -o h -l help,name:,rootid: -n $0 -- "$@")
    if [[ 1 = $? ]]; then
        wrong_parameter "$TARGET"
    fi
    eval set -- "$SARGS"
    while true ; do
	case "$1" in
            -h|--help)
                help_scmd_head "Build a $TARGET book"
                help_help
                help_name
                help_rootid
                echo
                exit 0
		;;
            --name)
                export PDFNAME="$2"
                export BOOK="$PDFNAME"
                shift 2
                ;;
	    --rootid)
		export ROOTID="$2"
		shift 2
		;;
            --) shift ; break ;;
            *) exit_on_error "Internal error!" ;;
	esac
    done

    call_make "$TARGET" "$@"
    
}

function filelists () {
    local TARGET=$1
    shift
    # command line args
    SARGS=$(getopt -o hp -l help,pretty -n $0 -- "$@")
    if [[ 1 = $? ]]; then
        wrong_parameter "$TARGET"
    fi
    eval set -- "$SARGS"
    while true ; do
	case "$1" in
            -h|--help)
                help_scmd_head "Print a list of $TARGET"
                help_help
                help_pretty
                echo
                exit 0
		;;
            -p|--pretty)
                if [[ 1 = $VERBOSE ]]; then
                    ccecho "warn" "Pretty printing is automatically disabled in verbose/debug mode"
                else
                    PRETTY_FILELIST=1
                fi
                shift
                ;;
            --) shift ; break ;;
            *) exit_on_error "Internal error!" ;;
	esac
    done
#    if [[ $TARGET =~ graphics ]]; then
#        call_make_nolog "profile" "$@"
#    fi
    call_make_nolog "$TARGET" "$@"
}

function packaging () {
    local TARGET=$1
    shift
    # command line args
    if [[ package-pdf = $TARGET ]]; then
        SARGS=$(getopt -o h -l fop:,help,name:,rootid: -n $0 -- "$@")
    elif [[ package-src = $TARGET ]]; then
        SARGS=$(getopt -o h -l extra-files:,help,name:,rootid: -n $0 -- "$@")
    else
        SARGS=$(getopt -o h -l help,name:,rootid: -n $0 -- "$@")
    fi
    if [[ 1 = $? ]]; then
        wrong_parameter "$TARGET"
    fi
    eval set -- "$SARGS"
    while true ; do
	case "$1" in
            --extra-files)
                for FILE in $2; do
                    test -f $FILE || exit_on_error "Cannot find extra file $FILE"
                done
                export EXTRA_FILES=$2
                shift 2
                ;;
            --fop)
                if [[ $2 = xep || $2 = fop ]]; then
                    export FOPTYPE="$2"
                    export FOP="${LIB_DIR}/daps-$2"
                else
		    exit_on_error "Wrong parameter for $1: must be \"xep\" or \"fop\"!"
                fi
		shift 2
		;;
            -h|--help)
                help_scmd_head "Build a $TARGET book"
                if [[ package-pdf = $TARGET ]]; then
                    help_fop
                elif [[ package-src = $TARGET ]]; then
                    help_extrafiles
                fi
                help_help
                help_name
                help_rootid
                echo
                exit 0
		;;
            --name)
                export PDFNAME="$2"
                export BOOK="$PDFNAME"
                shift 2
                ;;
	    --rootid)
		export ROOTID="$2"
		shift 2
		;;
            --) shift ; break ;;
            *) exit_on_error "Internal error!" ;;
	esac
    done

    call_make "$TARGET" "$@"
    
}
        
function show_env {
         echo "BASE_DIR=$BASE_DIR;ENVFILE=$ENVFILE"
}



# ----------------------------------------------------------------------------
# Help functions
#
# There are a lot of options, several functions have in common. I do
# not want to write the same text again and again, so I am providing
# extra functions for all help texts that appear more than once.

function help_scmd_head () {
    echo "
$ME [--global-options] $TARGET [options]

$1

  Command options:"
}

function help_comments () {
    echo "    --comments, -c            Include XML comments in profiled sources
                              Default: off"  
}
function help_compact () {
    echo "    --compact                 Print the filelist on a single line.
                              Ignored when -s|--show is set.
                              Default: off"  
}
function help_dirname () {
    echo "    --dirname=DIR             Directory names to be created in BASE_DIR
                              Default: generated by stripping 'ENV-' from the
                              ENV filename"
}
function help_draft () {
    echo "    --draft, -d               Add a 'DRAFT' watermark to all pages of the book
                              Default: off" 
}
function help_extrafiles () {
    echo "    --extra-files=FILES       Specify a space separated list of additional files to
                              be added to the source tarball. Paths must be
                              relative to BASE_DIR"
}
function help_file () {
    echo "    --file=FILE, -f FILE      Specify the filename of an XML file"
}
function help_fop () {
    echo "    --fop=FORMATTER           Specify the PDF formatter to be used. Currently
                              'xep' or 'fop' are supported.
                              Default: 'xep'"
}
function help_help () {
    echo "    --help, -h                Print this help text"
}
function help_modified () {
    echo "    --modified, -m            Print the image's modification time.
                              Ignored when -c is set.
                              Default: off"
}
function help_name () {
    echo "    --name=BOOKNAME           File- and directory names for generated content
                              are derived from BOOKNAME.
                              Default: generated by stripping 'ENV-' from the
                              ENV filename"
}
function help_nohelp () {
    echo "
No further help for subcommand \"$TARGET\" available.
"
}
function help_nopdf () {
    echo "    --nopdf, -n               Deactivates creating the color-pdf. Useful when
                              \"locdropping\" a complete set where you
                              want to deliver separate PDFs for each book
                              rather than one huge PDF for the whole set.
                              Default: off"
}
function help_meta () {
    echo "    --meta, -m                If set, prints additional status information
                              (filename, maintainer and status) for each file.
                              Implies draft mode.
                              Default: off"
}
function help_pretty () {
    echo "    --pretty, -p              Pretty print file lists (one filename per line)"
}
function help_remarks () {
    echo "    --remarks, -r             Include remarks (<remark>...</remark>) in book
                              Default: off"  
}
function help_rootelement () {
    echo "    --rootelement=ELEMENT     Specify a ROOTELEMENT for your main DocBook XML
                              file; must be one either article or book.
                              Default: book"
}
function help_rootid () {
    echo "    --rootid=ID               Specify a ROOTID to build only parts of a book
                              (parts or chapters). Default: Usually set
                              in the ENV-file; if not set the complete set
                              defined in $MAIN will be built"
}
function help_show () {
    echo "    --show, -s                Show images with an image viewer that either
                              has been specified with --viewer or by setting
                              IMG_VIEWER in the config file
                              Default: off"
}
function help_viewer () {
    echo "    --viewer                  Image viewer to be used.
                              Default: IMG_VIEWER setting from config file"
}
