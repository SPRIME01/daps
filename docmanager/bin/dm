#!/bin/sh
#
# "Aliases" for DocManager
#
# Author:
#   Thomas Schraitle <toms AT opensuse DOT org>
# July 2011


# Determine the absolute path of $0, this script
DIR="$(dirname $(readlink -f $0) )" #
PROG="$(basename $0)" #
DEBUG=0

# ---------
# Verbose error handling
#
function exit_on_error () {
  echo "error" "ERROR: ${1}"
  exit 1;
}

# generic sort function for all aliases - prints the table head
# and does the sorting with the rest of the output takes a sort parameter as optional
function sort_after_head () {
  for ((x=5 ; x-- ; )); do
    read line;
    echo $line;
  done;
  sort $*;
}


function debug () {
 if [[ $DEBUG = 1 ]]; then
   echo "DEBUG: ${1}"
 fi
}

function dm_help () {
  cat << EOF
$PROG [-e|--envfile|-b|--basedir] alias

Suffix on Subcommand means:
  d  deadline
  p  priority
  
Options and Subcommands:
EOF
  # Output all xxxx) + the following line and remove any whitespaces and ')'
  # If an option should NOT be displayed, use a hash mark at the end of the
  # parenthesis
  egrep -A1 -- " -?.*[a-z]\)$" $DIR/$PROG | sed 's/# //g;s/)//g;s/^--//g'
}

# ----------------------------------------------------------------------------
# Parsing the command line arguments with GNU getopt
#
# In order to separate general daps parameters from subcommand parameters,
# we are setting POSIXLY_CORRECT before parsing the first time.
# This causes getopt to interprete all remaining parameters as non-option
# parameters as soon as the first non-option parameter (the subcommand) is
# found. This value must be _exported_

export POSIXLY_CORRECT=1


ARGS=$(getopt -o h,d,b:e: -l help,debug,basedir:,envfile: -n "$ME" -- "$@") #
eval set -- "$ARGS"

while true ; do
  case "$1" in
    -b|--basedir)
      # Project directory. Must contain the XML sources in BASE_DIR/xml
      test -d "$2" || exit_on_error "BASE_DIR $2 is not a valid directory"
      BASE_DIR="$2"
      shift 2
      ;;

    -e|--envfile)
      # Specify which ENV file to use
      ENVFILE="$2"
      shift 2
      ;;

    -h|--help)
      # Outputs this help text
      dm_help
      exit 0
      ;;
    
    -d|--debug)
      # Enable debug messages
      DEBUG=1
      shift
      ;;
    --) shift; break ;;

    *) echo "Unknown subcommand"
     exit 1;
     ;;
  esac  
  
done

unset POSIXLY_CORRECT # we want the regular getopts behaviour on the second run

debug "After commandline parsing: ENVFILE=$ENVFILE, BASE_DIR=$BASE_DIR"

# Checks, if ENVFILE is set from commandline or by daps
if [[ -z $ENVFILE ]]; then
 # Call daps and see what he has to say about ENVFILE and BASE_DIR:
 ENV=$(daps showenv )
 if [[ 0 < $? ]]; then
   # daps returned != 0 (or an empty string in ENV) so neither --envfile
   # nor daps knows about it. Display an error:
   exit_on_error "No ENV file set"
 else
   # ENV contains BASE_DIR=/foo/bla/bar;ENVFILE=ENV-foo
   # The following construct extracts the BASE_DIR (b) and
   # the ENVFILE (e) with the help of an Bash array
   array=(${ENV//;/ }) #
   b="${array[0]}"
   e="${array[1]}"
   # Above array could also be evalulated with eval. I try to avoid this
   # and be on the safe side
   ENVFILE=${e##*=}
   if [[ -z $BASE_DIR ]]; then
     BASE_DIR=${b##*=}
   fi
 fi
fi

debug "After daps showenv: ENVFILE=$ENVFILE, BASE_DIR=$BASE_DIR"

# Extend variables with options:
if [[ ! -z $ENVFILE ]]; then
 ENVFILE="--envfile $ENVFILE"
fi
if [[ ! -z $BASE_DIR ]]; then
 BASE_DIR="--basedir $BASE_DIR"
fi

debug "Final state: ENVFILE=$ENVFILE, BASE_DIR=$BASE_DIR"

if [[ -z $1 ]]; then
    dm_help
    exit 0
else
    SUBCMD=$1
    shift
    declare -a SCMD_ARGS=( "$@" ) #
fi

#
# Define some Variable for often used docmanager arguments
#
MAINTAINER="doc:maintainer=${LOGNAME}"

COMMENTS="doc:status=comments"
EDITED="doc:status=edited"
EDITING="doc:status=editing"
LOCDROP="doc:status=locdrop"
PRELIM="doc:prelim=yes"
PROOFED="doc:status=proofed"
TRANS="doc:trans=yes"


# ATTENTION: If you modify these you may also have to modify the sort calls!!
#
QSTRING="%{name} '%{modified}' %{maintainer} %{trans} %{status} %{priority} %{deadline}\n"

REVPROP_QSTRING="%{name} %{trans} %{status} %{revprop} %{maintainer}\n"

MY_QSTRING="%{name} %{priority} %{deadline} %{trans} %{prelim} '%{modified}'\n"

case "$SUBCMD" in
  help)
    # Output help text
    dm_help
    exit 1
    ;;
# -------------------------------------------
# COMMENTS
#
  comments)
    # All files with doc:status=comments
    docmanager ${ENVFILE} ${BASE_DIR} dg -P -q "$QSTRING" \
        --include $COMMENTS "$@"
    ;;
  mycomments)
    # Your files with doc:status=comments
    docmanager ${ENVFILE} ${BASE_DIR} dg -P -q "$QSTRING" --include $COMMENTS \
        $MAINTAINER "$@"
    ;;
# -------------------------------------------
# EDITED
#
  edited)
    # All edited files with doc:status=edited
    docmanager ${ENVFILE} ${BASE_DIR} dg -P -q "$QSTRING" --include $EDITED "$@"
    ;;
  myedited)
    # Your edited files with doc:status=edited
    docmanager ${ENVFILE} ${BASE_DIR} dg -P -q "$MY_QSTRING" --include $EDITED \
        --include $MAINTAINER "$@"
    ;;
  editedd)
    # All files sorted after deadline
    docmanager ${ENVFILE} ${BASE_DIR} dg -P -q "$QSTRING" \
        "$@" | sort_after_head -k3
    ;;
  myeditedd)
    # Your files sorted after deadline
    docmanager ${ENVFILE} ${BASE_DIR} dg -P -q "$MY_QSTRING" --include $EDITED \
        --include $EDITED $MAINTAINER "$@" | sort_after_head -k3
    ;;
  editedp)
    # All files sorted after priority
    docmanager ${ENVFILE} ${BASE_DIR} dg -P -q "$QSTRING" --include $EDITED \
        "$@" | sort_after_head -k2 -n
    ;;
  myeditedp|workp)
    # Your files sorted after priority
    docmanager ${ENVFILE} ${BASE_DIR} dg -P -q "$MY_QSTRING" --include $EDITED \
        --include $MAINTAINER "$@" | sort_after_head -k2 -n
    ;;
# -------------------------------------------
# EDITING
#
  editing)
    # All files with doc:status=editing
    docmanager ${ENVFILE} ${BASE_DIR} dg -P -q "$QSTRING" \
        --include $EDITING "$@"
    ;;
  myediting|todo)
    # Your files with doc:status=editing
    docmanager ${ENVFILE} ${BASE_DIR} dg -P -q "$MY_QSTRING" \
        --include $EDITING --include $MAINTAINER "$@"
    ;;
  editingd)
    # All files with doc:status=editing sorted after deadline
    docmanager ${ENVFILE} ${BASE_DIR} dg -P -q "$QSTRING" --include $EDITING \
        "$@" | sort_after_head -k3 
    ;;
  myeditingd)
    # Your files with doc:status=editing sorted after deadline
    docmanager ${ENVFILE} ${BASE_DIR} dg -P -q "$MY_QSTRING" \
        --include $EDITING --include $MAINTAINER "$@" | sort_after_head -k3 
    ;;
  editingp)
    # All files with doc:status=editing sorted after priority
    docmanager ${ENVFILE} ${BASE_DIR} dg -P -q "$QSTRING" --include $EDITING \
        "$@" | sort_after_head -k2 -n
    ;;
  myeditingp)
    # Your files with doc:status=editing sorted after priority
    docmanager ${ENVFILE} ${BASE_DIR} dg -P -q "$MY_QSTRING" \
        --include $EDITING --include $MAINTAINER "$@" | sort_after_head -k2 -n
    ;;
# -------------------------------------------
# LOCDROP
#    
  locdrop)
    # All files which have to be translated and are set to locdrop
    docmanager ${ENVFILE} ${BASE_DIR} dg -P  -q "$REVPROP_QSTRING" \
        --include $LOCDROP "$@"
    ;;
# -------------------------------------------
# PRELIM
# 
  prelim)
    # All files with doc:prelim=yes
    docmanager ${ENVFILE} ${BASE_DIR} dg -P -q "$QSTRING" --include $PRELIM "$@"
    ;;
  myprelim)
    # Your files with doc:prelim=yes
    docmanager ${ENVFILE} ${BASE_DIR} dg -P -q "$MY_QSTRING" \
        --include $PRELIM --include $MAINTAINER "$@"
    ;;
# -------------------------------------------
# PROOFED
#
    proofed)
    # All files with doc:status=proofed
    docmanager ${ENVFILE} ${BASE_DIR} dg -P -q "$REVPROP_QSTRING" \
        --include $PROOFED "$@"
    ;;
  myproofed)
    # Your files with doc:status=proofed
    docmanager ${ENVFILE} ${BASE_DIR} dg -P -q "REVPROP_QSTRING" \
        --include $PROOFED --include $MAINTAINER "$@"
    ;;
# -------------------------------------------
# STAT
#
  stat)
    # All files including status column
    docmanager ${ENVFILE} ${BASE_DIR} dg -P -q "$QSTRING" "$@"
    ;;
  mystat|work)
    # Your files with including status column
    docmanager ${ENVFILE} ${BASE_DIR} dg -P -q "$MY_QSTRING" \
        --include $MAINTAINER "$@"
    ;;
  statd)
    # All files with status column sorted after deadline
    docmanager ${ENVFILE} ${BASE_DIR} dg -P  -q "$QSTRING" \
        "$@" | sort_after_head -k3
    ;;
  mystatd|workd)
    # Your files with status column sorted after deadline
    docmanager ${ENVFILE} ${BASE_DIR} dg -P -q "$MY_QSTRING" \
        --include $MAINTAINER "$@" | sort_after_head -k3
    ;;
  statd)
    # All files with status column sorted after priority
    docmanager ${ENVFILE} ${BASE_DIR} dg -P -q "$QSTRING" \
        "$@" | sort_after_head -k2
    ;;
  mystatd|workd)
    # Your files with status column sorted after priority
    docmanager ${ENVFILE} ${BASE_DIR} dg -P -q "$MY_QSTRING" \
        --include $MAINTAINER "$@" | sort_after_head -k2
    ;;
# -------------------------------------------
# TRANS
#    
  trans)
    # All files which have to be translated
    docmanager ${ENVFILE} ${BASE_DIR} dg -P -q "$QSTRING" --include $TRANS "$@"
    ;;
# -------------------------------------------
# Set Commands
#
  dscomments)
    # set files to comments
    docmanager ${ENVFILE} ${BASE_DIR} ds -C "$@"
    ;;
  dsproofed)
    # set files to proofed
    docmanager ${ENVFILE} ${BASE_DIR} ds -R "$@"
    ;;
  dsproofing)
    # set files to proofing
    docmanager ${ENVFILE} ${BASE_DIR} ds -P "$@"
    ;;
  dsediting)
    # set files to editing
    docmanager ${ENVFILE} ${BASE_DIR} ds -E "$@"
    ;;
  dsedited)
    # set files to edited
    docmanager ${ENVFILE} ${BASE_DIR} ds -D "$@"
    ;;
  dsprelim)
    # Unset prelim state; prelim = no
    docmanager ${ENVFILE} ${BASE_DIR} ds -y "$@"
    ;;
esac

# EOF
