#!/bin/sh
#
# "Aliases" for DocManager
#
# Author:
#   Thomas Schraitle <toms AT opensuse DOT org>
# July 2011


# Determine the absolute path of $0, this script
DIR="$(dirname $(readlink -f $0) )" #
PROG="$(basename $0)" #
DEBUG=0

# ---------
# Verbose error handling
#
function exit_on_error () {
  echo "error" "ERROR: ${1}"
  exit 1;
}

# generic sort function for all aliases - prints the table head
# and does the sorting with the rest of the output takes a sort parameter as optional
function sort_after_head () {
  for ((x=5 ; x-- ; )); do
    read line;
    echo $line;
  done;
  sort $*;
}


function debug () {
 if [[ $DEBUG = 1 ]]; then
   echo "DEBUG: ${1}"
 fi
}

function dm_help () {
  cat << EOF
$PROG [-e|--envfile|-b|--basedir] alias

Suffix on Subcommand means:
  d  deadline
  p  priority
  
Options and Subcommands:
EOF
  # Output all xxxx) + the following line and remove any whitespaces and ')'
  # If an option should NOT be displayed, use a hash mark at the end of the
  # parenthesis
  egrep -A1 -- " -?.*[a-z]\)$" $DIR/$PROG | sed 's/# //g;s/)//g;s/^--//g'
}

# ----------------------------------------------------------------------------
# Parsing the command line arguments with GNU getopt
#
# In order to separate general daps parameters from subcommand parameters,
# we are setting POSIXLY_CORRECT before parsing the first time.
# This causes getopt to interprete all remaining parameters as non-option
# parameters as soon as the first non-option parameter (the subcommand) is
# found. This value must be _exported_

export POSIXLY_CORRECT=1


ARGS=$(getopt -o h,d,b:e: -l help,debug,basedir:,envfile: -n "$ME" -- "$@") #
eval set -- "$ARGS"

while true ; do
  case "$1" in
    -b|--basedir)
      # Project directory. Must contain the XML sources in BASE_DIR/xml
      test -d "$2" || exit_on_error "BASE_DIR $2 is not a valid directory"
      BASE_DIR="$2"
      shift 2
      ;;

    -e|--envfile)
      # Specify which ENV file to use
      ENVFILE="$2"
      shift 2
      ;;

    -h|--help)
      # Outputs this help text
      dm_help
      exit 0
      ;;
    
    -d|--debug)
      # Enable debug messages
      DEBUG=1
      shift
      ;;
    --) shift; break ;;

    *) echo "Unknown subcommand"
     exit 1;
     ;;
  esac  
  
done

unset POSIXLY_CORRECT # we want the regular getopts behaviour on the second run

debug "After commandline parsing: ENVFILE=$ENVFILE, BASE_DIR=$BASE_DIR"

# Checks, if ENVFILE is set from commandline or by daps
if [[ -z $ENVFILE ]]; then
 # Call daps and see what he has to say about ENVFILE and BASE_DIR:
 ENV=$(daps showenv )
 if [[ 0 < $? ]]; then
   # daps returned != 0 (or an empty string in ENV) so neither --envfile
   # nor daps knows about it. Display an error:
   exit_on_error "No ENV file set"
 else
   # ENV contains BASE_DIR=/foo/bla/bar;ENVFILE=ENV-foo
   # The following construct extracts the BASE_DIR (b) and
   # the ENVFILE (e) with the help of an Bash array
   array=(${ENV//;/ }) #
   b="${array[0]}"
   e="${array[1]}"
   # Above array could also be evalulated with eval. I try to avoid this
   # and be on the safe side
   ENVFILE=${e##*=}
   if [[ -z $BASE_DIR ]]; then
     BASE_DIR=${b##*=}
   fi
 fi
fi

debug "After daps showenv: ENVFILE=$ENVFILE, BASE_DIR=$BASE_DIR"

# Extend variables with options:
if [[ ! -z $ENVFILE ]]; then
 ENVFILE="--envfile $ENVFILE"
fi
if [[ ! -z $BASE_DIR ]]; then
 BASE_DIR="--basedir $BASE_DIR"
fi

debug "Final state: ENVFILE=$ENVFILE, BASE_DIR=$BASE_DIR"

if [[ -z $1 ]]; then
    dm_help
    exit 0
else
    SUBCMD=$1
    shift
    declare -a SCMD_ARGS=( "$@" ) #
fi

case "$SUBCMD" in
  help)
    # Output help text
    dm_help
    exit 1
    ;;
  dgcomments)
    # Displays only files with doc:status=comments
    docmanager ${ENVFILE} ${BASE_DIR} dg -P -q --include="doc:status=comments"
    ;;
  dgedited)
    # Displays all edited files (doc:status=edited)
    docmanager ${ENVFILE} ${BASE_DIR} dg -P --include="doc:status=edited"
    ;;
  dgeditedp)
    # %{name} %{priority} %{prelim} %{maintainer}, sorted after priority
    docmanager ${ENVFILE} ${BASE_DIR} dg -P -q "%{name} %{priority} %{prelim} %{maintainer}\n" --include="doc:status=edited" | sort_after_head -k2 -n
    ;;
  dgeditedd)
    # %{name} %{deadline} %{prelim} %{maintainer}, sorted after deadline
    docmanager ${ENVFILE} ${BASE_DIR} dg -P -q "%{name} %{deadline} %{prelim} %{maintainer}\n" --include="doc:status=edited" | sort_after_head -k2
    ;;
  dgeditingx)
    # %{name} %{maintainer} %{status} %{deadline}, sorted after deadline
    docmanager ${ENVFILE} ${BASE_DIR} dg -P -q "%{name} %{maintainer} %{status} %{deadline}\n" --include="doc:status=editing" | sort_after_head -k4 
    ;;
  dglocdrop)
    # list files which have to be translated and are set to locdrop
    docmanager ${ENVFILE} ${BASE_DIR} dg -P -q "%{name} %{trans} %{status} %{revprop} %{maintainer}\n" --include="doc:status=locdrop"
    ;;
  dgprelim)
    # %{name} %{maintainer} %{status} %{prelim} %{deadline}, include only doc:prelim=yes
    docmanager ${ENVFILE} ${BASE_DIR} dg -P -q "%{name} %{maintainer} %{status} %{prelim} %{deadline} \n" --include "doc:prelim=yes"
    ;;
  dgproofed)
    # %{name} %{priority} %{status} %{revprop} %{maintainer}, include only proofed
    docmanager ${ENVFILE} ${BASE_DIR} dg -P -q "%{name} %{priority} %{status} %{revprop} %{maintainer}\n" --include="doc:status=proofed"
    ;;
  dgstat)
    # %{name} %{maintainer} %{trans} %{status} %{priority} %{deadline}
    docmanager ${ENVFILE} ${BASE_DIR} dg -P -q "%{name} %{maintainer} %{trans} %{status} %{priority} %{deadline} \n"
    ;;
  dgstatx)
    # %{name} %{maintainer} %{trans} %{status} %{deadline} and sorted after deadline
    docmanager ${ENVFILE} ${BASE_DIR} dg -P -q "%{name} %{maintainer} %{trans} %{status} %{deadline}\n" | sort_after_head -k5
    ;;
  dgtodo)
    # list all files owned by $LOGNAME that still need to be worked on
    docmanager ${ENVFILE} ${BASE_DIR} dg -P --include="doc:maintainer=${LOGNAME}" --include="doc:status=editing" -q "%{name} %{priority} %{modified} %{maintainer} %{release} %{trans} %{status} %{prelim}\n" | sort_after_head -k2
    ;;
  dgtrans)
    # list the files which have to be translated
    docmanager ${ENVFILE} ${BASE_DIR} dg -P -q  "%{name} %{trans} %{maintainer}\n" --include "doc:trans=yes"
    ;;
  dgwork)
    # Displays all files with doc:maintainer=${LOGNAME}
    docmanager ${ENVFILE} ${BASE_DIR} dg -P --include="doc:maintainer=${LOGNAME}"
    ;;
  dgworkp)
    # Displays all files with doc:maintainer=${LOGNAME} and sorted after deadline
    docmanager ${ENVFILE} ${BASE_DIR} dg -P --include="doc:maintainer=${LOGNAME}" -q "%{name} \'%{modified}\' %{priority} %{deadline} %{status} %{prelim}\n" | sort_after_head -k4
    ;;
  dgworkx)
    # Displays all files with doc:maintainer=${LOGNAME} and sorted after priority
    docmanager ${ENVFILE} ${BASE_DIR} dg -P --include="doc:maintainer=${LOGNAME}" --include="doc:status=editing" -q "%{name} %{priority} %{modified} %{maintainer} %{release} %{trans} %{status} %{prelim}\n" | sort_after_head -k2
    ;;

## Set Commands
  dscomments)
    # set files to comments
    docmanager ${ENVFILE} ${BASE_DIR} ds -C
    ;;
  dsproofed)
    # set files to proofed
    docmanager ${ENVFILE} ${BASE_DIR} ds -R
    ;;
  dsproofing)
    # set files to proofing
    docmanager ${ENVFILE} ${BASE_DIR} ds -P
    ;;
  dsediting)
    # set files to editing
    docmanager ${ENVFILE} ${BASE_DIR} ds -E
    ;;
  dsedited)
    # set files to edited
    docmanager ${ENVFILE} ${BASE_DIR} ds -D
    ;;
  dsprelim)
    # Unset prelim state; prelim = no
    docmanager ${ENVFILE} ${BASE_DIR} ds -y
    ;;
esac

# EOF