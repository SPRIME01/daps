#!/bin/bash
#
# Copyright (C) 2011-2013 Frank Sundermeyer <fsundermeyer@opensuse.org>
#
# Author:
# Frank Sundermeyer <fsundermeyer@opensuse.org>
#
# TODO: Checks for sources that do not get profiled
#
# Testing DAPS: HTML
#
# NOTE on jsp:
# jsp needs to be tested separately, since the original DocBook stylesheets,
# which are used for testing, do not support jsp
#
#
# In a PDF it's impossible to find out whether e.g. a certain XSLTPARAM
# option or the draft mode is working without actually opening the PDF
# in a viewer and looking at it.
# For testing we will therefore run DAPS in debug mode and grep for parameters
# in the log file. Thus we will at least know whether the xslt processor
# was called with correct options. 
#
# * Does the HTML correctly build?
# * Is an index.hml generated?
# * Does the name retrieved with *-dir-name match the actual result?
# * Are all images linked correctly?
# * Is the draft watermark image included when using the --draft option?
# * Are remarks displayed when using the --remarks option?
# * Is the meta information displayed when using the --meta option?
# * Does the --css switch work?
# * Does the --html5 switch produce XHTML5 ?
# * Is the --name option correctly implemented?
# * Does the --rootid option correctly work?
# * Are parameters pass with --xsltparam correctly processed?

# TODO: STYLEROOT, --clean, --statdir, --static
#
#


source lib/common_functions

header "$_HTMLCMD"

function oneTimeSetUp() {
    # Clean up the build directory
    clean_build
    # get the profiling directory
    _HTMLDIR_PATH=$(eval "$_DAPSEXEC -d $_DCFILE ${_HTMLCMD}-dir-name 2>/dev/null")
    if [ $? -ne 0 ]; then
	exit_on_error " The initial DAPS call to determine the path to the resulting HTML directory failed. Skipping tests"
    fi
    _LOG_DIR=$(eval "$_DAPSEXEC -v0 -d $_DCFILE showvariable VARIABLE=LOG_DIR 2>/dev/null")
    if [ $? -ne 0 ]; then
	exit_on_error " The initial DAPS call to determine the LOG file failed. Skipping tests"
    fi
    _LOGFILE=${_LOG_DIR}/make_${_HTMLCMD}.log
}

# Post
# this function is run _after_ the tests are executed
#
function oneTimeTearDown() {
    stats
    # Clean up the build directory
    clean_build
}

#---------------------------------------------------------------
# TESTS
#---------------------------------------------------------------

#--------------------------------
# * Does the HTML correctly build?
# * Is an index.hml generated?
# * Does the name retrieved with *-dir-name match the actual result?
#
function test_html () {
    local _HTMLDIR_NAME _HTMLFILE_NAME
    _HTMLFILE_NAME=$(eval "$_DAPSEXEC -v0 -d $_DCFILE $_HTMLCMD 2>/dev/null")
    assertTrue \
        ' └─ The $_HTMLCMD command itself failed' \
        "$?"
    assertTrue \
	" └─ The resulting file/link (${_HTMLFILE_NAME}) does not exist." \
	"[ -f $_HTMLDIR_NAME -o -L $_HTMLDIR_NAME ]"
    assertTrue \
	" └─ The result directory does not contain index.html" \
	"[ -f $_HTMLDIR_PATH/index.html -o -L $_HTMLDIR_PATH/index.html ]"

    # If a ROOTID was specified, no index.html is  generated by the stylesheets
    # In this case we manually generate one in the makefile
    # Here we test if a link (in case it exists) points to a real file
    # If no link, this test is skipped
    #
    if [ ! -L $_HTMLFILE_NAME ]; then
	startSkipping
    else
	readlink -e $_HTMLFILE_NAME >/dev/null 2>&1
    fi
    assertTrue \
	" └─ The resulting link (${_HTMLFILE_NAME}) does not point to an existing file" \
	"$?"
    endSkipping

    _HTMLDIR_NAME=$(dirname $_HTMLFILE_NAME)
    assertEquals \
	" └─ The resulting filename does not match the one retrieved with --${_HTMLCMD}-dir-name" \
	"$_HTMLDIR_PATH" "$_HTMLDIR_NAME"
}


#--------------------------------
# * Are all images linked correctly?

function test_htmlImages () {
    local _oldIFS _J _IMAGE _IMGS _IMGS_DAPS _IMG_DIFF _IMG_REFS _MISSING
    declare -a _IMGS_BUILD
    declare -a _IMGS_EXPECTED

    clean_build

    eval "$_DAPSEXEC -v0 -d $_DCFILE $_HTMLCMD >/dev/null 2>&1"
    assertTrue \
        ' └─ The $_HTMLCMD command itself failed' \
        "$?"

    #
    # Check if image links in the HTML point to existing files
    #
    _IMG_REFS=$(grep -il '\<img ' ${_HTMLDIR_PATH}/*.html)


    # get list of images using lynx
    #
    _IMGS=$(lynx -dump -listonly -image-links $_IMG_REFS | grep "${_HTMLDIR_PATH}/images/" | sed 's/^\s*[0-9]*\.\s*file:\/\/localhost//g' | sort -u)

    for _IMAGE in $_IMGS; do
	readlink -e $_IMAGE >/dev/null 2>&1
	[ $? != 0 ] && _MISSING="$_MISSING $_IMAGE"
    done
    assertNull \
	" └─ Image links in the HTML are dead: $_MISSING" \
	"$_MISSING"
    _IMGS_DAPS=$(eval "$_DAPSEXEC -v0 -d $_DCFILE list-srcfiles --nodc --noent --noxml")
    assertTrue \
	" └─ The command 'list-srcfiles --nodc --noent --noxml' failed" \
	"$?"
    assertNotNull \
	" └─ The command 'list-srcfiles --nodc --noent --noxml' returned an empty string" \
	"_IMGS_DAPS"
    #
    # Check if list of images retrieved from DAPS matches the ones
    # retrieved from the HTML (see above)
    J=0
    for _IMAGE in $_IMGS_DAPS; do
	_IMGS_EXPECTED[$J]="${_HTMLDIR_PATH}/images/$(basename $_IMAGE)"
	# skip JPEGs 
	if [[ ${_IMGS_EXPECTED[$J]##*.} != jpg ]]; then
	    _IMGS_EXPECTED[$J]="${_IMGS_EXPECTED[$J]%.*}.png"
	fi
	let J++
    done
    _IMGS_BUILD=( $_IMGS )

    # Now we have two lists - "expected images" and "build images". The latter
    # may contain additional images (e.g. for callouts), but the "expected
    # images" all need to appear in "build images". We can check this by using 
    # comm: comm -1 -3 <BUILT> <EXPECTED> will show images unique to
    # <EXPECTED> - there should be none. Since comm compares columns, we also
    # need to operate with a modified IFS
    #
    _oldIFS=$IFS IFS=$'\n\t'
    _IMG_DIFF=$(comm -1 -3 <(echo "${_IMGS_BUILD[*]}" | sort -u) <(echo "${_IMGS_EXPECTED[*]}" | sort -u))
    IFS=$_oldIFS
    assertNull \
	" └─ The list of images from DAPS does not match the ones from the HTML" \
	"$_IMG_DIFF"

}

#--------------------------------
# * Is the draft watermark image included when using the --draft option?
# * Are remarks displayed when using the --remarks option?
# * Is the meta information displayed when using the --meta option?
#

function test_htmlRemarksDraftMeta () {
    local _HTMLDIR_NAME _HTMLFILE_NAME_BUILD

    clean_build

    _HTMLFILE_NAME_BUILD=$(eval "$_DAPSEXEC -d $_DCFILE --debug $_HTMLCMD --draft --remarks --meta 2>/dev/null | tail -n 1")
   assertTrue \
       ' └─ Building HTML with --draft --remarks --meta failed' \
       "$?"
   _HTMLDIR_NAME_BUILD=$(dirname $_HTMLFILE_NAME_BUILD)
   _HTMLDIR_NAME=$(eval "$_DAPSEXEC -v0 -d $_DCFILE ${_HTMLCMD}-dir-name --draft --remarks --meta 2>/dev/null")
   assertTrue \
       ' └─ Getting the HTML-dir-name with --draft --remarks --meta failed' \
       "$?"
   assertEquals \
       " └─ The resulting filename does not match the one retrieved with --${_PDFCMD}-name: " \
       "$_HTMLDIR_NAME" "$_HTMLDIR_NAME_BUILD"

   # checking DRAFT mode
   #
   egrep -- "background-image.*draft.png" ${_HTMLDIR_NAME_BUILD}/*.html >/dev/null 2>&1
   assertTrue \
       ' └─ Generated HTML does not seem to have a DRAFT bg-image' \
       "$?"
   expr "$_HTMLDIR_NAME_BUILD" : '.*\(_draft\)' >/dev/null 2>&1
   assertTrue \
       ' └─ String "_draft" does not appear in the HTML-dir-name' \
       "$?"

   # checking REMARKS
   #
   grep -- "class=\"remark\"" ${_HTMLDIR_NAME_BUILD}/*.html >/dev/null 2>&1
   assertTrue \
       ' └─ Generated HTML does not seem to show remarks' \
       "$?"
   expr "$_HTMLDIR_NAME_BUILD" : '.*\(_remarks\)' >/dev/null 2>&1
   assertTrue \
       ' └─ String "_remarks" does not appear in the HTML-dir-name' \
       "$?"

   # checking META
   #
   egrep -- "--param\s+\"use\.meta=1\"" $_LOGFILE >/dev/null 2>&1
   assertTrue \
       ' └─ Param for META is not correctly specified.' \
       "$?"
   expr "$_HTMLDIR_NAME_BUILD" : '.*\(_meta\)' >/dev/null 2>&1
   assertTrue \
       ' └─ String "_meta" does not appear in the HTML-dir-name' \
       "$?"
}

#--------------------------------
# * Does the --css switch work?
# * Does the --html5 switch produce XHTML5 ?
#

function test_htmlCSS_HTML5 () {
    local _CSS_BUILD _CSS_FILE _CSS_PATH

    _CSS_FILE="test.css"
    _CSS_PATH="${_DOC_DIR}/xml/${_CSS_FILE}"
    _CSS_BUILD="${_HTMLDIR_PATH}/static/css/${_CSS_FILE}"

    clean_build

    eval "$_DAPSEXEC -v0 -d $_DCFILE $_HTMLCMD --css=${_CSS_PATH} --html5 >/dev/null 2>&1"
    assertTrue \
        ' └─ The $_HTMLCMD command with --css and --html5 failed' \
        "$?"
    assertTrue \
	" └─ The result directory does not contain index.html" \
	"[ -f $_HTMLDIR_PATH/index.html -o -L $_HTMLDIR_PATH/index.html ]"
    # Test for HTML5
    #
    grep "<\!DOCTYPE html>" ${_HTMLDIR_PATH}/index.html >/dev/null 2>&1
    assertTrue \
        ' └─ The resulting HTML does not have a valid XHTML5 Doctype declaration.' \
        "$?"
    # Test CSS
    #
    assertTrue \
	" └─ The result directory does not contain ${_CSS_BUILD}" \
	"[ -f ${_CSS_BUILD} -o -L ${_CSS_BUILD} ]"
    grep "static/css/${_CSS_FILE}" ${_HTMLDIR_PATH}/index.html >/dev/null 2>&1
    assertTrue \
        ' └─ The resulting HTML does not include a link to static/css/${_CSS_FILE}.' \
        "$?"    
}

#--------------------------------
# * Is the --name option correctly implemented?
#
function test_htmlNAME () {
    local _BUILD_SUBDIR_NAME _NAME _PDFPATH _PDFPATH_BUILD
    _NAME="testsuite"

    clean_build

    _HTMLFILE_NAME_BUILD=$(eval "$_DAPSEXEC -v0 -d $_DCFILE $_HTMLCMD --name $_NAME 2>/dev/null")
    assertTrue \
	" └─ Building a $_HTMLCMD document with --name failed " \
       "$?"
    _HTMLSUBDIR_NAME_BUILD=$(basename $(dirname $_HTMLFILE_NAME_BUILD))
    assertEquals \
	' └─ The subdirectory name of the build result does not match the string given with --name:' \
	"$_NAME" "$_HTMLSUBDIR_NAME_BUILD"
    
    _HTMLDIR_NAME=$(eval "$_DAPSEXEC -v0 -d $_DCFILE ${_HTMLCMD}-dir-name --name $_NAME 2>/dev/null")
   assertTrue \
       ' └─ Getting the HTML-dir-name with --draft --remarks --meta failed' \
       "$?"
   _HTMLSUBDIR_NAME=$(basename $_HTMLDIR_NAME)
    assertEquals \
	" └─ The subdirectory name retrieved with ${_HTMLCMD}-dir-name does not match the string given with --name:" \
	"$_NAME" "$_HTMLSUBDIR_NAME"
}

#--------------------------------
# * Does the --rootid option work correctly?
# * Are parameters pass with --xsltparam correctly processed?
#
function test_htmlRootidXsltparam () {
    local _FILECOUNT _FILECOUNT_EXPECTED _HTMLDIR_PATH_BUILD
    local _HTMLDIR_PATH_ROOTID _ROOTID _XSLTPARAM

    _ROOTID=appendix
    _FILECOUNT_EXPECTED=1
    _HTMLDIR_PATH_ROOTID="$(dirname $(dirname $_HTMLDIR_PATH))/$_HTMLCMD/$_ROOTID"
    # will generate HTML files with .xhtml extension
    _XSLTPARAM="--param \\\"spacing.paras=1\\\""

    clean_build

    _HTMLFILE_BUILD=$(eval "$_DAPSEXEC -d $_DCFILE --debug $_HTMLCMD --rootid $_ROOTID --xsltparam=\"'$_XSLTPARAM'\" 2>/dev/null | tail -n 1")
    assertTrue \
	' └─ Building a $_HTMLCMD document with --rootid and --xsltparam failed ' \
       "$?"
    egrep -- "--stringparam\s+\"rootid=$_ROOTID\"" $_LOGFILE >/dev/null 2>&1
    assertTrue \
	' └─ Stringparam for ROOTID is not correctly specified when generating the FO-file' \
	"$?"
    _HTMLDIR_PATH_BUILD=$(dirname $_HTMLFILE_BUILD)
    assertEquals \
	' └─ The resulting HTML dirname does not match the ROOTID:' \
	"$_HTMLDIR_PATH_ROOTID" "$_HTMLDIR_PATH_BUILD"
    # check HTML file count - should be one real file
    # (only make sense for HTML, since single-html is only one file anyway)
    #
    if [[ $_HTMLCMD == html ]]; then
	_FILECOUNT=$(find $_HTMLDIR_PATH_BUILD -type f -name "*.html" | wc -l)
    else
	startSkipping
    fi
    assertEquals \
	' └─ Wrong HTML file count:' \
	"$_FILECOUNT_EXPECTED" "$_FILECOUNT"
    endSkipping
    # check xsltparam
    egrep -- "$_XSLTPARAM" $_LOGFILE >/dev/null 2>&1
    assertTrue \
	' └─ Param for XSLTPARAM is not correctly specified when generating HTML' \
	"$?"
}


# source shUnit2 test
eval "source $_SHUNIT2SRC"
