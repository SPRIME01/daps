<!-- Converted by db4-upgrade version 1.1 -->

<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:id="cha.qemu.running">
  <title>Running Virtual Machines with qemu-system-ARCH</title>
  <para>
  Once you have a virtual disk image ready (for more information on disk
  images, see <xref linkend="cha.qemu.guest_inst.qemu-img"/>), it is time to
  start the related virtual machine.
  <xref linkend="cha.qemu.guest_inst.qemu-kvm"/> introduced simple commands
  to install and run a VM Guest. This chapter focuses on a more detailed
  explanation of <command>qemu-system-ARCH</command> usage, and shows
  solutions for more specific tasks. For a complete list of
  <command>qemu-system-ARCH</command>'s options, see its manual page
  (<command>man 1 qemu</command>).
 </para>
  <sect1 xml:id="cha.qemu.running.basic">
    <title>Basic <command>qemu-system-ARCH</command> Invocation</title>
    <para>
   The <command>qemu-system-ARCH</command> command uses the following
   syntax:
  </para>
    <screen>qemu-system-ARCH options<co xml:id="co.qemu.running.basic.opts"/> disk_img<co xml:id="co.qemu.running.basic.img"/></screen>
    <calloutlist>
      <callout arearefs="co.qemu.running.basic.opts">
        <para><command>qemu-system-ARCH</command> understands a large number of
     options. Most of them define parameters of the emulated hardware, while
     others affect more general emulator behavior. If you do not supply any
     options, default values are used, and you need to supply the path to a
     disk image to be run.
    </para>
      </callout>
      <callout arearefs="co.qemu.running.basic.img">
        <para>
     Path to the disk image holding the guest system you want to virtualize.
     <command>qemu-system-ARCH</command> supports a large number of image
     formats. Use <command>qemu-img <option>--help</option></command> to
     list them. If you do not supply the path to a disk image as a separate
     argument, you have to use the <option>-drive file=</option> option.
    </para>
      </callout>
    </calloutlist>
  </sect1>
  <sect1 xml:id="cha.qemu.running.gen_opts">
    <title>General <command>qemu-system-ARCH</command> Options</title>
    <para>
   This section introduces general <command>qemu-system-ARCH</command>
   options and options related to the basic emulated hardware, such as the
   virtual machine's processor, memory, model type, or time processing
   methods.
  </para>
    <variablelist>
      <varlistentry>
        <term>
          <literal>-name <replaceable>name_of_guest</replaceable></literal>
        </term>
        <listitem>
          <para>
      Specifies the name of the running guest system. The name is displayed
      in the window caption and also used for the VNC server.
     </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <literal>-boot <replaceable>options</replaceable></literal>
        </term>
        <listitem>
          <para>
      Specifies the order in which the defined drives will be booted. Drives
      are represented by letters, where 'a' and 'b' stands for the floppy
      drives 1 and 2, 'c' stands for the first hard disk, 'd' stands for the
      first CD-ROM drive, and 'n' to 'p' stand for Ether-boot network
      adapters.
     </para>
          <para>
      For example, <literal>qemu-system-ARCH [...] -boot order=ndc</literal>
      first tries to boot from network, then from the first CD-ROM drive,
      and finally from the first hard disk.
     </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <literal>-pidfile <replaceable>fname</replaceable></literal>
        </term>
        <listitem>
          <para>
      Stores the QEMU's process identification number (PID) in a file.
      This is useful if you run QEMU from a script.
     </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <literal>-nodefaults</literal>
        </term>
        <listitem>
          <para>
      By default QEMU creates basic virtual devices even if you do not
      specify them on the command line. This option turns this feature off,
      and you must specify every single device manually, including graphical
      and network cards, parallel or serial ports, or virtual consoles. Even
      QEMU monitor is not attached by default.
     </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <literal>-daemonize</literal>
        </term>
        <listitem>
          <para>
      'Daemonizes' the QEMU process after it is started. QEMU will
      detach from the standard input and standard output after it is ready
      to receive connections on any of its devices.
     </para>
        </listitem>
      </varlistentry>
    </variablelist>
    <note>
      <title>Seabios Bios</title>
      <para>
    Seabios is the default Bios used. You can boot USB devices, any drive
    (CDROM, Floppy, or an hard drive disk). It has USB mouse and keyboard
    support and support multiple VGA cards. For more information about
    Seabios refer to
    <link xlink:href="http://en.wikipedia.org/wiki/SeaBIOS">http://en.wikipedia.org/wiki/SeaBIOS</link>.
   </para>
    </note>
    <sect2 xml:id="cha.qemu.running.gen_opts.basic">
      <title>Basic Virtual Hardware</title>
      <para/>
      <sect3 xml:id="sec.qemu.running.gen_opts.machine">
        <title>Machine Type</title>
        <para>
     You can specifies the type of the emulated machine. Run
     <command>qemu-system-ARCH -M help</command> to view a list of supported
     machine types.
    </para>
        <screen><prompt role="user">tux &gt; </prompt>qemu-system-x86_64 -M help
Supported machines are:
pc-0.13              Standard PC (i440FX + PIIX, 1996)
pc                   Standard PC (i440FX + PIIX, 1996) (alias of pc-i440fx-2.0)
pc-i440fx-2.0        Standard PC (i440FX + PIIX, 1996) (default)
pc-1.0               Standard PC (i440FX + PIIX, 1996)
pc-q35-1.7           Standard PC (Q35 + ICH9, 2009)
pc-1.1               Standard PC (i440FX + PIIX, 1996)
q35                  Standard PC (Q35 + ICH9, 2009) (alias of pc-q35-2.0)
pc-q35-2.0           Standard PC (Q35 + ICH9, 2009)
pc-i440fx-1.4        Standard PC (i440FX + PIIX, 1996)
pc-i440fx-1.5        Standard PC (i440FX + PIIX, 1996)
pc-0.14              Standard PC (i440FX + PIIX, 1996)
pc-0.15              Standard PC (i440FX + PIIX, 1996)
xenfv                Xen Fully-virtualized PC
pc-q35-1.4           Standard PC (Q35 + ICH9, 2009)
isapc                ISA-only PC
pc-0.10              Standard PC (i440FX + PIIX, 1996)
pc-1.2               Standard PC (i440FX + PIIX, 1996)
pc-0.11              Standard PC (i440FX + PIIX, 1996)
pc-i440fx-1.7        Standard PC (i440FX + PIIX, 1996)
pc-i440fx-1.6        Standard PC (i440FX + PIIX, 1996)
none                 empty machine
xenpv                Xen Para-virtualized PC
pc-q35-1.5           Standard PC (Q35 + ICH9, 2009)
pc-q35-1.6           Standard PC (Q35 + ICH9, 2009)
pc-0.12              Standard PC (i440FX + PIIX, 1996)
pc-1.3               Standard PC (i440FX + PIIX, 1996)</screen>
        <note>
          <title>ISA-PC</title>
          <para><emphasis>isapc ISA-ony-PC</emphasis> is an unsupported machine type.
     </para>
        </note>
      </sect3>
      <sect3 xml:id="cha.qemu.running.gen_opts.basic.cpu">
        <title>CPU Model</title>
        <para>
     To specify the type of the processor (CPU) model, run
     <command>qemu-system-ARCH -cpu
     <replaceable>MODEL</replaceable></command>. Use
     <command>qemu-system-ARCH -cpu help</command> to view a list of
     supported CPU models.
    </para>
        <screen><prompt role="user">tux &gt; </prompt>qemu-system-x86_64 -cpu help
x86           qemu64  QEMU Virtual CPU version 2.0.0                  
x86           phenom  AMD Phenom(tm) 9550 Quad-Core Processor         
x86         core2duo  Intel(R) Core(TM)2 Duo CPU     T7700  @ 2.40GHz 
x86            kvm64  Common KVM processor                            
x86           qemu32  QEMU Virtual CPU version 2.0.0                  
x86            kvm32  Common 32-bit KVM processor                     
x86          coreduo  Genuine Intel(R) CPU           T2600  @ 2.16GHz 
x86              486                                                  
x86          pentium                                                  
x86         pentium2                                                  
x86         pentium3                                                  
x86           athlon  QEMU Virtual CPU version 2.0.0                  
x86             n270  Intel(R) Atom(TM) CPU N270   @ 1.60GHz          
x86           Conroe  Intel Celeron_4x0 (Conroe/Merom Class Core 2)   
x86           Penryn  Intel Core 2 Duo P9xxx (Penryn Class Core 2)    
x86          Nehalem  Intel Core i7 9xx (Nehalem Class Core i7)       
x86         Westmere  Westmere E56xx/L56xx/X56xx (Nehalem-C)          
x86      SandyBridge  Intel Xeon E312xx (Sandy Bridge)                
x86          Haswell  Intel Core Processor (Haswell)                  
x86       Opteron_G1  AMD Opteron 240 (Gen 1 Class Opteron)           
x86       Opteron_G2  AMD Opteron 22xx (Gen 2 Class Opteron)          
x86       Opteron_G3  AMD Opteron 23xx (Gen 3 Class Opteron)          
x86       Opteron_G4  AMD Opteron 62xx class CPU                      
x86       Opteron_G5  AMD Opteron 63xx class CPU                      
x86             host  KVM processor with all supported host features (only
                      available in KVM mode)
Recognized CPUID flags:
  pbe ia64 tm ht ss sse2 sse fxsr mmx acpi ds clflush pn pse36 pat cmov mca
    pge mtrr sep apic cx8 mce pae msr tsc pse de vme fpu
  hypervisor rdrand f16c avx osxsave xsave aes tsc-deadline popcnt movbe
    x2apic sse4.2|sse4_2 sse4.1|sse4_1 dca pcid pdcm xtpr cx16 fma cid ssse3
    tm2 est smx vmx ds_cpl monitor dtes64 pclmulqdq|pclmuldq pni|sse3
  smap adx rdseed rtm invpcid erms bmi2 smep avx2 hle bmi1 fsgsbase
  3dnow 3dnowext lm|i64 rdtscp pdpe1gb fxsr_opt|ffxsr mmxext nx|xd syscall
  perfctr_nb perfctr_core topoext tbm nodeid_msr tce fma4 lwp wdt skinit xop
    ibs osvw 3dnowprefetch misalignsse sse4a abm cr8legacy extapic svm
    cmp_legacy lahf_lm
  pmm-en pmm phe-en phe ace2-en ace2 xcrypt-en xcrypt xstore-en xstore
  kvm_pv_unhalt kvm_pv_eoi kvm_steal_time kvm_asyncpf kvmclock kvm_mmu
    kvm_nopiodelay kvmclock
  pfthreshold pause_filter decodeassists flushbyasid vmcb_clean tsc_scale
    nrip_save svm_lock lbrv npt</screen>
        <para>
     CPU flags information can be found at
     <link xlink:href="http://en.wikipedia.org/wiki/CPUID">http://en.wikipedia.org/wiki/CPUID</link>.
    </para>
      </sect3>
      <sect3 xml:id="cha.qemu.running.gen_opts.basic.others">
        <title>Other Basics Options</title>
        <para>
     The following is a list of most commonly used options while launching
     <emphasis>qemu</emphasis> from command line. To see all options
     available please refer to <emphasis>qemu-doc</emphasis> manpage.
    </para>
        <variablelist>
          <varlistentry>
            <term>
              <literal>-m <replaceable>megabytes</replaceable></literal>
            </term>
            <listitem>
              <para>
        Specifies how many megabytes are used for the virtual RAM size.
       </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <literal>-balloon virtio</literal>
            </term>
            <listitem>
              <para>
        Specifies a paravirtualized device to dynamically change the amount
        of virtual RAM memory assigned to VM Guest. The top limit is the
        amount of memory specified with <literal>-m</literal>.
       </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <literal>-smp <replaceable>number_of_cpus</replaceable></literal>
            </term>
            <listitem>
              <para>
        Specifies how many CPUs will be emulated. QEMU supports up to 255
        CPUs on the PC platform (up to 64 with KVM acceleration used). This
        option also takes other CPU-related parameters, such as number of
        <emphasis>sockets</emphasis>, number of <emphasis>cores</emphasis>
        per socket, or number of <emphasis>threads</emphasis> per core.
       </para>
            </listitem>
          </varlistentry>
        </variablelist>
        <para>
     The following is an example of a working
     <command>qemu-system-ARCH</command> command line:
     <remark>taroth 2014-08-29: maybe update the following with a SLE 12 example?</remark></para>
        <screen>qemu-system-x86_64 -name "SLES 11 SP3" -M pc-i440fx-2.0 -m 512 -machine accel=kvm \
       -cpu kvm64 -smp 2 /images/sles.raw</screen>
        <figure>
          <title>QEMU Window with SLES 11 SP3 as VM Guest</title>
          <mediaobject>
            <imageobject role="fo">
              <imagedata fileref="qemu_win_sles.png" width="70%" format="PNG"/>
            </imageobject>
            <imageobject role="html">
              <imagedata fileref="qemu_win_sles.png" width="70%" format="PNG"/>
            </imageobject>
          </mediaobject>
        </figure>
        <variablelist>
          <varlistentry>
            <term>
              <literal>-no-acpi</literal>
            </term>
            <listitem>
              <para>
        Disables <xref linkend="gloss.vt.acpi"/> support.
       </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <literal>-S</literal>
            </term>
            <listitem>
              <para>
        QEMU starts with CPU stopped. To start CPU, enter
        <literal>c</literal> in QEMU monitor. For more information, see
        <xref linkend="cha.qemu.monitor"/>.
       </para>
            </listitem>
          </varlistentry>
        </variablelist>
      </sect3>
    </sect2>
    <sect2 xml:id="cha.qemu.running.gen_opts.storing_cong">
      <title>Storing and Reading Configuration of Virtual Devices</title>
      <variablelist>
        <varlistentry>
          <term>
            <literal>-readconfig <replaceable>cfg_file</replaceable></literal>
          </term>
          <listitem>
            <para>
       Instead of entering the devices configuration options on the command
       line each time you want to run VM Guest,
       <command>qemu-system-ARCH</command> can read it from a file that was
       either previously saved with <literal>-writeconfig</literal> or
       edited manually.
      </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <literal>-writeconfig <replaceable>cfg_file</replaceable></literal>
          </term>
          <listitem>
            <para>
       Dumps the current virtual machine's devices configuration to a text
       file. It can be consequently re-used with the
       <literal>-readconfig</literal> option.
       <remark>taroth 2014-08-29: maybe
       update the following with a SLE 12 example? We can but SLE11SP3 is
       still supported, so that's ok</remark></para>
            <screen><prompt role="user">tux &gt; </prompt> qemu-system-ARCH -name "SLES 11 SP3" -M pc-i440fx-2.0 -m 512 -cpu kvm64 \
-smp 2 /images/sles.raw -writeconfig /images/sles.cfg
(exited)
<prompt role="user">tux &gt; </prompt> more /images/sles.cfg
# qemu config file

[drive]
  index = "0"
  media = "disk"
  file = "/images/sles_base.raw"</screen>
            <para>
       This way you can effectively manage the configuration of your virtual
       machines' devices in a well-arranged way.
      </para>
          </listitem>
        </varlistentry>
      </variablelist>
    </sect2>
    <sect2 xml:id="cha.qemu.running.gen_opts.rtc">
      <title>Guest Real-Time Clock</title>
      <variablelist>
        <varlistentry>
          <term>
            <literal>-rtc <replaceable>options</replaceable></literal>
          </term>
          <listitem>
            <para>
       Specifies the way the RTC is handled inside a VM Guest. By default,
       the clock of the guest is derived from that of the host system.
       Therefore, it is recommended that the host system clock is
       synchronized with an accurate external clock (for example, via NTP
       service).
      </para>
            <para>
       If you need to isolate the VM Guest clock from the host one, specify
       <literal>clock=vm</literal> instead of the default
       <literal>clock=host</literal>.
      </para>
            <para>
       You can also specify a 'starting point' for VM Guest clock with the
       <literal>base</literal> option:
      </para>
            <screen>qemu-system-ARCH [...] -rtc clock=vm,base=2010-12-03T01:02:00</screen>
            <para>
       Instead of a timestamp, you can specify <literal>utc</literal> or
       <literal>localtime</literal>. The former instructs VM Guest to start
       at the current UTC value (Coordinated Universal Time, see
       <link xlink:href="http://en.wikipedia.org/wiki/UTC"/>), while the latter
       applies the local time setting.
      </para>
          </listitem>
        </varlistentry>
      </variablelist>
    </sect2>
    <!--
  #!/bin/sh
  #set -x
  bridge=br0
  tap=$(/usr/bin/sudo /bin/tunctl -u $(/usr/bin/whoami) -b)

  /usr/bin/sudo /sbin/ip link set $tap up
  sleep 0.5s
  /usr/bin/sudo /sbin/brctl addif $bridge $tap

  /usr/bin/qemu-system-ARCH -m 512 \
  -boot order=cd,menu=on \
  -drive
  file=/local/kvm/sles11-SP1-vnc15.raw,if=virtio,cache=none,aio=native,boot=on \
  -net nic,model=virtio,macaddr=52:54:00:12:45:80 -net
  tap,ifname=$tap,script=no,downscript=no \
  -vga std \
  -usb -usbdevice tablet \
  -balloon virtio \
  -writeconfig /local/kvm/test.cfn \
  -vnc :15 -k de

  /usr/bin/sudo /sbin/brctl delif $bridge $tap
  /usr/bin/sudo /sbin/ip link set $tap down
  /usr/bin/sudo /bin/tunctl -d $tap
  -->
  </sect1>
  <sect1 xml:id="cha.qemu.running.devices">
    <title>Using Devices in QEMU</title>
    <para>
   QEMU virtual machines emulate all devices needed to run a VM Guest.
   QEMU supports, for example, several types of network cards, block
   devices (hard and removable drives), <phrase condition="kvm4x86">USB
   devices, </phrase>character devices (serial and parallel
   ports)<phrase condition="kvm4x86">, or multimedia devices (graphic and
   sound cards)</phrase>. This section introduces options to configure
   various types of supported devices.
  </para>
    <tip>
      <para>
    If your device, such as <literal>-drive</literal>, needs a special
    driver and driver properties to be set, specify them with the
    <literal>-device</literal> option, and identify with
    <literal>drive=</literal> suboption. For example:
   </para>
      <screen>qemu [...] -drive if=none,id=drive0,format=raw \
-device virtio-blk-pci,drive=drive0,scsi=off ...</screen>
      <para>
    To get help on available drivers and their properties, use
    <option>-device ?</option> and <option>-device
    <replaceable>driver</replaceable>,?</option>.
   </para>
    </tip>
    <sect2 xml:id="cha.qemu.running.devices.block">
      <title>Block Devices</title>
      <para>
    Block devices are vital for virtual machines. In general, these are
    fixed or removable storage media usually referred to as 'drives'. One of
    the connected hard drives typically holds the guest operating system to
    be virtualized.
   </para>
      <para><xref linkend="gloss.vt.vm"/> drives are defined with
    <literal>-drive</literal>. This option uses many suboptions, some of
    which are described in this section. For their complete list, see the
    manual page (<command>man 1 qemu</command>).
   </para>
      <variablelist>
        <title>Sub-options for the <literal>-drive</literal> Option</title>
        <varlistentry>
          <term>
            <literal>file=image_fname</literal>
          </term>
          <listitem>
            <para>
       Specifies the path to the disk image that will be used with this
       drive. If not specified, an empty (removable) drive is assumed.
      </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <literal>if=drive_interface</literal>
          </term>
          <listitem>
            <para>
       Specifies the type of interface to which the drive is connected.
       Currently only <literal>floppy</literal>, <literal>scsi</literal>,
       <literal>ide</literal>, or <literal>virtio</literal> are supported by
       SUSE. <literal>virtio</literal> defines a paravirtualized disk
       driver. Default is <literal>ide</literal>.
      </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <literal>index=index_of_connector</literal>
          </term>
          <listitem>
            <para>
       Specifies the index number of a connector on the disk interface (see
       the <literal>if</literal> option) where the drive is connected. If
       not specified, the index is automatically incremented.
      </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <literal>media=type</literal>
          </term>
          <listitem>
            <para>
       Specifies the type of media. Can be <literal>disk</literal> for
       hard disks, or <literal>cdrom</literal> for removable CD-ROM drives.
      </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <literal>format=img_fmt</literal>
          </term>
          <listitem>
            <para>
       Specifies the format of the connected disk image. If not specified,
       the format is autodetected. Currently, SUSE supports
       <literal>qcow2</literal>, <literal>qed</literal> and
       <literal>raw</literal> formats.
      </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <literal>cache=method</literal>
          </term>
          <listitem>
            <para>
       Specifies the caching method for the drive. Possible values are
       <literal>unsafe</literal>, <literal>writethrough</literal>,
       <literal>writeback</literal>, <literal>directsync</literal>, or
       <literal>none</literal>. For the <literal>qcow2</literal> image
       format, choose <literal>writeback</literal> if you care about
       performance. <literal>none</literal> disables the host page cache
       and, therefore, is the safest option. Default for image files is
       <literal>writeback</literal>. For more information, see
       <xref linkend="cha.qemu.cachemodes"/>.
      </para>
          </listitem>
        </varlistentry>
      </variablelist>
      <tip>
        <para>
     To simplify defining of block devices, QEMU understands several
     shortcuts which you may find handy when entering the
     <literal>qemu-system-ARCH</literal> command line.
    </para>
        <para>
     You can use
    </para>
        <screen>qemu-system-ARCH -cdrom /images/cdrom.iso</screen>
        <para>
     instead of
    </para>
        <screen>qemu-system-ARCH -drive file=/images/cdrom.iso,index=2,media=cdrom</screen>
        <para>
     and
    </para>
        <screen>qemu-system-ARCH -hda /images/imagei1.raw -hdb /images/image2.raw -hdc \
/images/image3.raw -hdd /images/image4.raw</screen>
        <para>
     instead of
    </para>
        <screen>qemu-system-ARCH -drive file=/images/image1.raw,index=0,media=disk \
-drive file=/images/image2.raw,index=1,media=disk \
-drive file=/images/image3.raw,index=2,media=disk \
-drive file=/images/image4.raw,index=3,media=disk</screen>
      </tip>
      <tip>
        <title>Using Host Drives Instead of Images</title>
        <para>
     As an alternative to using disk images (see
     <xref linkend="cha.qemu.guest_inst.qemu-img"/>) you can also use
     existing VM Host Server disks, connect them as drives, and access them from
     VM Guest. Use the host disk device directly instead of disk image
     file names.
    </para>
        <para>
     To access the host CD-ROM drive, use
    </para>
        <screen>qemu-system-ARCH [...] -drive file=/dev/cdrom,media=cdrom</screen>
        <para>
     To access the host hard disk, use
    </para>
        <screen>qemu-system-ARCH [...] -drive file=/dev/hdb,media=disk</screen>
        <para>
     A host drive used by a VM Guest must not be accessed concurrently by
     the VM Host Server or another VM Guest.
    </para>
      </tip>
      <sect3 xml:id="kvm.freedisk">
        <title>Freeing Unused Guest Disk Space</title>
        <para>
     A <xref linkend="gloss.vt.storage.sparse"/> is a type of disk image
     file that grows in size as the user adds data to it, taking up only as
     much disk space as is stored in it. For example, if you copy 1 GB of data
     inside the sparse disk image, its size grows by 1 GB. If you then
     delete for example 500 MB of the data, the image size does not by
     default decrease as expected.
    </para>
        <para>
     That is why the <option>discard=on</option> option is introduced on the
     KVM command line. It tells the hypervisor to automatically free the
     'holes' after deleting data from the sparse guest image. Note that this
     option is valid only for the <literal>if=scsi</literal> drive
     interface:
    </para>
        <screen>qemu-system-ARCH [...] -drive file=/path/to/file.img,if=scsi,discard=on</screen>
        <warning>
          <para><option>if=scsi</option> is not supported. This interface doesn't map
      to <emphasis>virtio-scsi</emphasis>, but rather to the <emphasis>lsi
      scsi adapter</emphasis>.
     </para>
        </warning>
      </sect3>
      <sect3 xml:id="kvm.virtio_data_plane">
        <title>virtio-blk-data-plane</title>
        <para>
     The <emphasis>virtio-blk-data-plane</emphasis> is a new performance
     feature for KVM. It enables a high-performance code path for I/O
     requests coming from VM Guests. More specifically, this feature
     introduces dedicated threads (one per virtual block device) to process
     I/O requests going through the <emphasis>virtio-blk</emphasis> driver.
     It makes use of Linux AIO (asynchronous I/O interface) support in the
     VM Host Server Kernel directly—without the need to go through the QEMU
     block layer. Therefore it can sustain very high I/O rates on storage
     setups.
    </para>
        <para>
     The virtio-blk-data-plane feature can be enabled or disabled by the
     <option>x-data-plane=on|off</option> option on the
     <command>qemu</command> command line when starting the VM Guest:
    </para>
        <screen>qemu [...] -drive if=none,id=drive0,cache=none,aio=native,\
format=raw,file=filename -device virtio-blk-pci,drive=drive0,scsi=off,\
config-wce=off,x-data-plane=on [...]</screen>
        <para>
     As of now, the virtio-blk-data-plane has the following limitations:
    </para>
        <itemizedlist>
          <listitem>
            <para>
       Only raw image format is supported.
      </para>
          </listitem>
          <listitem>
            <para>
       No support for live migration.
      </para>
          </listitem>
          <listitem>
            <para>
       Block jobs and hot unplug operations fail with -EBUSY.
      </para>
          </listitem>
          <listitem>
            <para>
       I/O throttling limits are ignored.
      </para>
          </listitem>
          <listitem>
            <para>
       Only Linux VM Host Servers are supported because of the Linux AIO usage,
       but non-Linux VM Guests are supported.
      </para>
          </listitem>
        </itemizedlist>
        <important>
          <para>
      The virtio-blk-data-plane feature is not yet supported in
      <phrase role="productname"><phrase os="osuse">openSUSE</phrase><phrase os="sles">SUSE Linux Enterprise Server</phrase><phrase os="sled">SUSE Linux Enterprise Desktop</phrase><phrase os="slerte">SUSE Linux Enterprise Real Time Extension</phrase></phrase>. It is released as a technical preview only.
     </para>
        </important>
      </sect3>
      <sect3 xml:id="kvm.virtio_blk.use_bio">
        <title>Bio-Based I/O Path for virtio-blk</title>
        <para>
     For better performance of I/O-intensive applications, a new I/O path
     was introduced for the virtio-blk interface in kernel version 3.7. This
     bio-based block device driver skips the I/O scheduler, and thus
     shortens the I/O path in guest and has lower latency. It is especially
     useful for high-speed storage devices, such as SSD disks.
    </para>
        <para>
     The driver is disabled by default. To use it, do the following:
    </para>
        <procedure>
          <step>
            <para>
       Append <command>virtio_blk.use_bio=1</command> to the kernel command
       line on the guest. You can do so via
       <menuchoice><guimenu>YaST</guimenu><guimenu>System</guimenu><guimenu>Boot
       Loader</guimenu></menuchoice>.
      </para>
            <para>
       You can do it also by editing <filename>/etc/default/grub</filename>,
       searching for the line that contains
       <emphasis>GRUB_CMDLINE_LINUX_DEFAULT=</emphasis>, and adding the kernel
       parameter at the end. Then run <command>grub2-mkconfig
       &gt;/boot/grub2/grub.cfg</command> to update the grub2 boot menu.
      </para>
          </step>
          <step>
            <para>
       Reboot the guest with the new kernel command line active.
      </para>
          </step>
        </procedure>
        <tip>
          <title>Bio-Based Driver on Slow Devices</title>
          <para>
      The bio-based virtio-blk driver does not help on slow devices such as
      spin hard disks. The reason is that the benefit of scheduling is
      larger than what the shortened bio path offers. Do not use the
      bio-based driver on slow devices.
     </para>
        </tip>
      </sect3>
    </sect2>
    <sect2 xml:id="cha.qemu.running.devices.graphic">
      <title>Graphic Devices and Display Options</title>
      <para>
    This section describes QEMU options affecting the type of the emulated
    video card and the way VM Guest graphical output is displayed.
   </para>
      <sect3 xml:id="cha.qemu.running.devices.graphic.vga">
        <title>Defining Video Cards</title>
        <para>
     QEMU uses <literal>-vga</literal> to define a video card used to
     display VM Guest graphical output. The <literal>-vga</literal> option
     understands the following values:
    </para>
        <variablelist>
          <varlistentry>
            <term>
              <literal>none</literal>
            </term>
            <listitem>
              <para>
        Disables video cards on VM Guest (no video card is emulated). You
        can still access the running VM Guest via the serial console.
       </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <literal>std</literal>
            </term>
            <listitem>
              <para>
        Emulates a standard VESA 2.0 VBE video card. Use it if you intend to
        use high display resolution on VM Guest.
       </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <literal>cirrus</literal>
            </term>
            <listitem>
              <para>
        Emulates Cirrus Logic GD5446 video card. Good choice if you insist
        on high compatibility of the emulated video hardware. Most operating
        systems (even Windows 95) recognize this type of card.
       </para>
              <tip>
                <para>
         For best video performance with the <literal>cirrus</literal> type,
         use 16-bit color depth both on VM Guest and VM Host Server.
        </para>
              </tip>
            </listitem>
          </varlistentry>
        </variablelist>
      </sect3>
      <sect3 xml:id="cha.qemu.running.devices.graphic.display">
        <title>Display Options</title>
        <para>
     The following options affect the way VM Guest graphical output is
     displayed.
    </para>
        <variablelist>
          <varlistentry>
            <term>
              <literal>-sdl</literal>
            </term>
            <listitem>
              <para>
        Enables SDL.
       </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <literal>-spice option[,option[,...]]</literal>
            </term>
            <listitem>
              <para>
        Enables the spice remote desktop protocol.
       </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <literal>-vnc display[,option[,option[,...]]]</literal>
            </term>
            <listitem>
              <para>
        Refer to <xref linkend="cha.qemu.running.vnc"/> for more
        information.
       </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <literal>-nographic</literal>
            </term>
            <listitem>
              <para>
        Disables QEMU's graphical output. The emulated serial port is
        redirected to the console.
       </para>
              <para>
        After starting the virtual machine with
        <literal>-nographic</literal>, press
        <keycombo><keycap function="control"/><keycap>A</keycap></keycombo><keycap>H</keycap> in the virtual console to view the list of other
        useful shortcuts, for example, to toggle between the console and the
        QEMU monitor.
       </para>
              <screen><prompt role="user">tux &gt; </prompt> qemu-system-ARCH -hda /images/sles_base.raw -nographic

C-a h    print this help
C-a x    exit emulator
C-a s    save disk data back to file (if -snapshot)
C-a t    toggle console timestamps
C-a b    send break (magic sysrq)
C-a c    switch between console and monitor
C-a C-a  sends C-a
(pressed C-a c)

QEMU 2.0.0 monitor - type 'help' for more information
(qemu)</screen>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <literal>-no-frame</literal>
            </term>
            <listitem>
              <para>
        Disables decorations for the QEMU window. Convenient for dedicated
        desktop workspace.
       </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <literal>-full-screen</literal>
            </term>
            <listitem>
              <para>
        Starts QEMU graphical output in full screen mode.
       </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <literal>-no-quit</literal>
            </term>
            <listitem>
              <para>
        Disables the 'close' button of QEMU window and prevents it from
        being closed by force.
       </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <literal>-alt-grab, -ctrl-grab</literal>
            </term>
            <listitem>
              <para>
        By default QEMU window releases the 'captured' mouse after
        <keycombo><keycap>Ctrl</keycap><keycap>Alt</keycap></keycombo> is
        pressed. You can change the key combination to either
        <keycombo><keycap>Ctrl</keycap><keycap>Alt</keycap><keycap>Shift</keycap></keycombo>
        (<literal>-alt-grab</literal>), or <keycap>Right Ctrl</keycap>
        (<literal>-ctrl-grab</literal>).
       </para>
            </listitem>
          </varlistentry>
        </variablelist>
      </sect3>
    </sect2>
    <sect2 xml:id="cha.qemu.running.devices.usb" condition="kvm4x86">
      <title>USB Devices</title>
      <para>
    There are two ways to create USB devices usable by the VM Guest in
    KVM: you can either emulate new USB devices inside a VM Guest, or
    assign an existing host USB device to a VM Guest. To use USB devices in
    QEMU you first need to enable the generic USB driver with the
    <option>-usb</option> option. Then you can specify individual devices
    with the <option>-usbdevice</option> option.
   </para>
      <sect3 xml:id="kvm.usb.emulate">
        <title>Emulating USB Devices in VM Guest</title>
        <para>
     SUSE currently supports the following types of USB devices:
     <literal>disk</literal>, <literal>host</literal>,
     <literal>serial</literal>, <literal>braille</literal>,
     <literal>net</literal><literal>mouse</literal> and
     <literal>tablet</literal>.
    </para>
        <variablelist>
          <title>Types of USB devices for the <literal>-usbdevice</literal> option</title>
          <varlistentry>
            <term>
              <literal>disk</literal>
            </term>
            <listitem>
              <para>
        Emulates a mass storage device based on file. The optional
        <literal>format</literal> option is used rather than detecting the
        format.
       </para>
              <screen>qemu-system-ARCH [...] -usbdevice
        disk:format=raw:/virt/usb_disk.raw</screen>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <literal>host</literal>
            </term>
            <listitem>
              <para>
        Pass through the host device (identified by bus.addr).
       </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <literal>serial</literal>
            </term>
            <listitem>
              <para>
        Serial converter to a host character device.
       </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <literal>braille</literal>
            </term>
            <listitem>
              <para>
        Emulates a braille device using BrlAPI to display the braille
        output.
       </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <literal>net</literal>
            </term>
            <listitem>
              <para>
        Emulates a network adapter that supports CDC Ethernet and RNDIS
        protocols.
       </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <literal>mouse</literal>
            </term>
            <listitem>
              <para>
        Emulates a virtual USB mouse. This option overrides the default PS/2
        mouse emulation. The following example shows the hardware status of
        a mouse on VM Guest started with <literal>qemu-system-ARCH [...]
        -usbdevice mouse</literal>:
       </para>
              <screen><prompt role="user">tux &gt; </prompt> sudo hwinfo --mouse
20: USB 00.0: 10503 USB Mouse
[Created at usb.122]
UDI: /org/freedesktop/Hal/devices/usb_device_627_1_1_if0
[...]
Hardware Class: mouse
Model: "Adomax QEMU USB Mouse"
Hotplug: USB
Vendor: usb 0x0627 "Adomax Technology Co., Ltd"
Device: usb 0x0001 "QEMU USB Mouse"
[...]</screen>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <literal>tablet</literal>
            </term>
            <listitem>
              <para>
        Emulates a pointer device that uses absolute coordinates (such as
        touchscreen). This option overrides the default PS/2 mouse
        emulation. The tablet device is useful if you are viewing VM Guest
        via the VNC protocol. See <xref linkend="cha.qemu.running.vnc"/> for
        more information.
       </para>
            </listitem>
          </varlistentry>
        </variablelist>
      </sect3>
      <sect3 xml:id="kvm.usb.passthru">
        <title>USB Pass-Through</title>
        <para>
     To assign an existing host USB device to a VM Guest, you need to find
     out its host bus and device ID.
    </para>
        <screen>tux@vmhost:~&gt; lsusb
[...]
Bus 002 Device 005: ID 12d1:1406 Huawei Technologies Co., Ltd. E1750
[...]</screen>
        <para>
     In the above example, we want to assign a USB stick connected to the
     host's USB bus number 2 with device number 5. Now run the VM Guest
     with the following additional options:
    </para>
        <screen>qemu-system-ARCH [...] -usb -device usb-host,hostbus=2,hostaddr=5</screen>
        <para>
     After the guest is booted, check that the assigned USB device is
     present on it.
    </para>
        <screen>tux@vmguest:~&gt; lsusb
[...]
Bus 001 Device 002: ID 12d1:1406 Huawei Technologies Co., Ltd. E1750
[...]</screen>
        <note>
          <para>
      The guest operating system must take care of mounting the assigned USB
      device so that it is accessible for the user.
     </para>
        </note>
      </sect3>
    </sect2>
    <sect2 xml:id="kvm.pciback" condition="kvm4x86">
      <title>PCI Pass-Through</title>
      <para>
    PCI Pass-Through is a technique to give your VM Guest exclusive access to a
    PCI device.
   </para>
      <note>
        <title>Prereqisites</title>
        <para>
     To make use of PCI Pass-Through, your motherboard chipset, BIOS, and CPU must
     have support for <xref linkend="gloss.vt.acronym.iommu"/> (AMD) or
     <xref linkend="gloss.vt.acronym.vtd"/> (Intel) virtualization
     technology. To make sure that your computer supports this feature, ask
     your supplier specifically to deliver a system that supports PCI Pass-Through.
    </para>
        <para>
     Assigning graphics cards is not supported by SUSE.
    </para>
      </note>
      <note>
        <title>Consider Using libvirt for Setting Up PCI Pass-Through</title>
        <para>
     There are some factors affecting successful PCI Pass-Through that are best
     handled programmatically. If you encounter problems, consider instead
     relying on libvirt to manage guests that use PCI Pass-Through devices. Refer
     to <xref linkend="sec.libvirt.config.pci.virsh"/> or
     <xref linkend="sec.libvirt.config.pci"/> for details.
    </para>
      </note>
      <procedure>
        <title>Configuring PCI Pass-Through</title>
        <step>
          <para>
      Check whether <xref linkend="gloss.vt.acronym.iommu"/> is actively
      enabled and recognized on the host. Run <command>sudo dmesg | grep -e
      DMAR -e IOMMU</command> on Intel machines, or <command>sudo dmesg |
      grep AMD-Vi</command> on AMD machines. If you get no output, edit your
      boot loader configuration and add <literal>intel_iommu=on</literal>
      (Intel machines) or <literal>iommu=pt iommu=1</literal> (AMD
      machines). Then reboot the host machine. Also make sure that
      <xref linkend="gloss.vt.acronym.iommu"/>
      (<xref linkend="gloss.vt.acronym.vtd"/>) has been enabled in the
      BIOS/firmware.
     </para>
        </step>
        <step>
          <para>
      Identify the host PCI device to assign to the guest.
     </para>
          <screen>tux@vmhost:~&gt; sudo lspci -nn
[...] 00:1b.0 Audio device [0403]: Intel Corporation 82801H (ICH8 Family) \
HD Audio Controller [8086:284b] (rev 02) [...]</screen>
          <para>
      Note down the device (<literal>00:1b.0</literal>) and vendor
      (<literal>8086:284b</literal>) ID.
     </para>
        </step>
        <step>
          <para>
      Unbind the device from host Kernel driver and bind it to the PCI stub
      driver.
     </para>
          <screen>tux@vmhost:~&gt; sudo modprobe pci_stub
tux@vmhost:~&gt; sudo echo "8086 284b" &gt; /sys/bus/pci/drivers/pci-stub/new_id
tux@vmhost:~&gt; sudo echo "0000:00:1b.0" &gt; /sys/bus/pci/devices/0000:00:1b.0/driver/unbind
tux@vmhost:~&gt; sudo echo "0000:00:1b.0" &gt; /sys/bus/pci/drivers/pci-stub/bind</screen>
        </step>
        <step>
          <para>
      Now run the VM Guest with the PCI device assigned.
     </para>
          <screen>qemu-system-ARCH [...] -device pci-assign,host=00:1b.0</screen>
        </step>
      </procedure>
      <note>
        <para>
     If the PCI device shares IRQ with other devices, it cannot be assigned
     to a VM Guest.
    </para>
      </note>
      <para>
    KVM also supports PCI device hotplugging to a VM Guest. To achieve
    this, you need to switch to a QEMU monitor (see
    <xref linkend="cha.qemu.monitor"/> for more information) and issue
    the following commands:
   </para>
      <itemizedlist>
        <listitem>
          <para>
      hot-add:
     </para>
          <screen>device_add pci-assign,host=00:1b.0,id=new_pci_device</screen>
        </listitem>
        <listitem>
          <para>
      hot-remove:
     </para>
          <screen>device_del new_pci_device</screen>
        </listitem>
      </itemizedlist>
    </sect2>
    <sect2 xml:id="kvm.vfio">
      <title>VFIO: Secure Direct Access to Devices</title>
      <para><xref linkend="vt.io.vfio"/> stands for <emphasis>Virtual Function
    I/O</emphasis> and is a new user-level driver framework for Linux. It is
    meant to replace the traditional PCI device assignment. The
    <xref linkend="vt.io.vfio"/> driver exposes direct device access to
    userspace in a secure memory (<xref linkend="gloss.vt.acronym.iommu"/>)
    protected environment.
   </para>
      <para>
    Compared to KVM PCI device assignment, <xref linkend="vt.io.vfio"/>
    interface has the following advantages:
   </para>
      <itemizedlist>
        <listitem>
          <para>
      Resource access is compatible with secure boot.
     </para>
        </listitem>
        <listitem>
          <para>
      Device is isolated and its memory access protected.
     </para>
        </listitem>
        <listitem>
          <para>
      Offers user space device driver with more flexible device ownership
      model.
     </para>
        </listitem>
        <listitem>
          <para>
      Is independent of KVM technology, and not bound to x86 architecture
      only.
     </para>
        </listitem>
      </itemizedlist>
      <sect3 xml:id="kvm.vfio.groups">
        <title>IOMMU Groups</title>
        <para>
     The <xref linkend="gloss.vt.acronym.iommu"/> (input/output memory
     management unit that connects a direct memory access-capable I/O bus to
     the main memory) API supports the notion of groups. A group is a set of
     devices that can be isolated from all other devices in the system.
     Groups are therefore the unit of ownership used by
     <xref linkend="vt.io.vfio"/>.
    </para>
        <para>
     To find the <xref linkend="gloss.vt.acronym.iommu"/> group for your PCI
     device, you first need to identify it. Use <command>hwinfo</command> or
     <command>lspci</command> to find its bus ID. Suppose you want to find an
     <xref linkend="gloss.vt.acronym.iommu"/> group for the following
     device:
    </para>
        <screen>01:10.0 Ethernet controller: Intel Corporation 82576 Virtual Function (rev 01)</screen>
        <para>
     Run the following to find the group:
    </para>
        <screen># readlink /sys/bus/pci/devices/0000:01:10.0/iommu_group
../../../../kernel/iommu_groups/15</screen>
        <para>
     The <xref linkend="gloss.vt.acronym.iommu"/> group number is 15. Now
     you can check the devices belonging to the same
     <xref linkend="gloss.vt.acronym.iommu"/> group:
    </para>
        <screen>ls -l /sys/bus/pci/devices/0000:01:10.0/iommu_group/devices/0000:01:10.0
[...] 0000:00:1e.0 -&gt; ../../../../devices/pci0000:00/0000:00:1e.0
[...] 0000:01:10.0 -&gt; ../../../../devices/pci0000:00/0000:00:1e.0/0000:01:10.0
[...] 0000:01:10.1 -&gt; ../../../../devices/pci0000:00/0000:00:1e.0/0000:01:10.1</screen>
      </sect3>
      <sect3 xml:id="kvm.vfio.assign">
        <title>Device Assignment</title>
        <para>
     To assign a device to <xref linkend="vt.io.vfio"/> driver, follow these
     steps:
    </para>
        <procedure>
          <step>
            <para>
       Unbind the device from the device driver:
      </para>
            <screen># echo 0000:01:10.0 | sudo tee \
/sys/bus/pci/devices/0000:01:10.0/driver/unbind</screen>
          </step>
          <step>
            <para>
       Find the vendor and device ID of the PCI device you want to assign to
       <xref linkend="vt.io.vfio"/>:
      </para>
            <screen># lspci -n -s 01:10.0
01:10.0 0200: 8086:10ca (rev 01)</screen>
          </step>
          <step>
            <para>
       Load the <literal>vfio-pci</literal> driver:
      </para>
            <screen># modprobe vfio-pci</screen>
          </step>
          <step>
            <para>
       Now bind the device to the <literal>vfio-pci</literal> driver:
      </para>
            <screen># echo 8086 10ca | sudo tee \
/sys/bus/pci/drivers/vfio-pci/new_id</screen>
          </step>
          <step>
            <para>
       After the assignment is done, check the vfio device belongs to
       <xref linkend="gloss.vt.acronym.iommu"/> group 15:
      </para>
            <screen># ls /dev/vfio
15 vfio</screen>
          </step>
        </procedure>
      </sect3>
      <sect3 xml:id="kvm.vfio.start">
        <title>Starting <command>qemu-system-ARCH</command> with <literal>vfio-pci</literal></title>
        <para>
     After you assigned the PCI device to the <literal>vfio-pci</literal>
     driver, you can include it in the <command>qemu-system-ARCH</command>
     command line:
    </para>
        <screen># sudo qemu-system-ARCH [...] -device vfio-pci,host=01:10.0,id=net0</screen>
      </sect3>
      <sect3 xml:id="kvm.vfio.more">
        <title>For More Information</title>
        <para>
     You can find more detailed information on the
     <xref linkend="vt.io.vfio"/> driver in the
     <filename>/usr/src/linux/Documentation/vfio.txt</filename> file
     (package <systemitem>kernel-source</systemitem> has to be installed).
    </para>
        <para>
     You can find a useful (but slightly outdated) presentation at
     <link xlink:href="http://www.linux-kvm.org/wiki/images/b/b4/2012-forum-VFIO.pdf"/>.
    </para>
      </sect3>
    </sect2>
    <sect2 xml:id="cha.qemu.running.devices.char">
      <title>Character Devices</title>
      <para>
    Use <literal>-chardev</literal> to create a new character device. The
    option uses the following general syntax:
   </para>
      <screen>qemu-system-ARCH [...] -chardev <replaceable>backend_type</replaceable>,id=<replaceable>id_string</replaceable></screen>
      <para>
    where <replaceable>backend_type</replaceable> can be one of
    <literal>null</literal>, <literal>socket</literal>,
    <literal>udp</literal>, <literal>msmouse</literal>,
    <literal>vc</literal>, <literal>file</literal>, <literal>pipe</literal>,
    <literal>console</literal>, <literal>serial</literal>,
    <literal>pty</literal>, <literal>stdio</literal>,
    <literal>braille</literal>, <literal>tty</literal>, or
    <literal>parport</literal>. All character devices must have a unique
    identification string up to 127 characters long. It is used to identify
    the device in other related directives. For the complete description of
    all back-end's suboptions, see the manual page (<command>man 1
    qemu</command>). A brief description of the available
    <literal>back-ends</literal> follows:
   </para>
      <variablelist>
        <varlistentry>
          <term>
            <literal>null</literal>
          </term>
          <listitem>
            <para>
       Creates an empty device that outputs no data and drops any data it
       receives.
      </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <literal>stdio</literal>
          </term>
          <listitem>
            <para>
       Connects to QEMU's process standard input and standard output.
      </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <literal>socket</literal>
          </term>
          <listitem>
            <para>
       Creates a two-way stream socket. If <replaceable>path</replaceable>
       is specified, a Unix socket is created:
      </para>
            <screen>qemu-system-ARCH [...] -chardev \
socket,id=unix_socket1,path=/tmp/unix_socket1,server</screen>
            <para>
       The <replaceable>server</replaceable> suboption specifies that the
       socket is a listening socket.
      </para>
            <para>
       If <replaceable>port</replaceable> is specified, a TCP socket is
       created:
      </para>
            <screen>qemu-system-ARCH [...] -chardev \
socket,id=tcp_socket1,host=localhost,port=7777,server,nowait</screen>
            <para>
       The command creates a local listening (<literal>server</literal>) TCP
       socket on port 7777. QEMU will not block waiting for a client to
       connect to the listening port (<literal>nowait</literal>).
      </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <literal>udp</literal>
          </term>
          <listitem>
            <para>
       Sends all network traffic from VM Guest to a remote host over the
       UDP protocol.
      </para>
            <screen>qemu-system-ARCH [...] -chardev udp,id=udp_fwd,host=mercury.example.com,port=7777</screen>
            <para>
       The command binds port 7777 on the remote host mercury.example.com and sends
       VM Guest network traffic there.
      </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <literal>vc</literal>
          </term>
          <listitem>
            <para>
       Creates a new QEMU text console. You can optionally specify the
       dimensions of the virtual console:
      </para>
            <screen>qemu-system-ARCH [...] -chardev vc,id=vc1,width=640,height=480 -mon chardev=vc1</screen>
            <para>
       The command creates a new virtual console called
       <literal>vc1</literal> of the specified size, and connects the QEMU
       monitor to it.
      </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <literal>file</literal>
          </term>
          <listitem>
            <para>
       Logs all traffic from VM Guest to a file on VM Host Server. The
       <literal>path</literal> is required and will be created if it does
       not exist.
      </para>
            <screen>qemu-system-ARCH [...] -chardev file,id=qemu_log1,path=/var/log/qemu/guest1.log</screen>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
    By default QEMU creates a set of character devices for serial and
    parallel ports, and a special console for QEMU monitor. You can,
    however, create your own character devices and use them for the just
    mentioned purposes. The following options will help you:
   </para>
      <variablelist>
        <varlistentry>
          <term>
            <literal>-serial <replaceable>char_dev</replaceable></literal>
          </term>
          <listitem>
            <para>
       Redirects the VM Guest's virtual serial port to a character device
       <replaceable>char_dev</replaceable> on VM Host Server. By default, it is a
       virtual console (<literal>vc</literal>) in graphical mode, and
       <literal>stdio</literal> in non-graphical mode. The
       <literal>-serial</literal> understands many suboptions. See the
       manual page <command>man 1 qemu</command> for a complete list of them.
      </para>
            <para>
       You can emulate up to 4 serial ports. Use <literal>-serial
       none</literal> to disable all serial ports.
      </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <literal>-parallel <replaceable>device</replaceable></literal>
          </term>
          <listitem>
            <para>
       Redirects the VM Guest's parallel port to a
       <replaceable>device</replaceable>. This option supports the same
       devices as <literal>-serial</literal>.
      </para>
            <tip>
              <para>
        With SUSE Linux Enterprise Server as a VM Host Server, you can directly use the hardware parallel
        port devices <filename>/dev/parportN</filename> where
        <literal>N</literal> is the number of the port.
       </para>
            </tip>
            <para>
       You can emulate up to 3 parallel ports. Use <literal>-parallel
       none</literal> to disable all parallel ports.
      </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <literal>-monitor <replaceable>char_dev</replaceable></literal>
          </term>
          <listitem>
            <para>
       Redirects the QEMU monitor to a character device
       <replaceable>char_dev</replaceable> on VM Host Server. This option supports
       the same devices as <literal>-serial</literal>. By default, it is a
       virtual console (<literal>vc</literal>) in a graphical mode, and
       <literal>stdio</literal> in non-graphical mode.
      </para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
    For a complete list of available character devices back-ends, see the
    man page (<command>man 1 qemu</command>).
   </para>
    </sect2>
  </sect1>
  <sect1 xml:id="cha.qemu.running.networking">
    <title>Networking in QEMU</title>
    <para>
   Use the <literal>-net</literal> option to define a network interface and
   a specific type of networking for your VM Guest. Currently, SUSE
   supports the following options: <literal>none</literal>,
   <literal>nic</literal>, <literal>user</literal>,
   <literal>bridge</literal>, and <literal>tap</literal>. For a complete
   list of <literal>-net</literal> suboptions, see the manual page
   (<command>man 1 qemu</command>).
  </para>
    <variablelist>
      <title>Supported <literal>-net</literal> Suboptions</title>
      <varlistentry>
        <term>
          <literal>bridge</literal>
        </term>
        <listitem>
          <para>
      Uses a specified network helper to configure the TAP interface and
      attach it to a specified bridge. For more information, see
      <xref linkend="cha.qemu.running.networking.bridge"/>.
     </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <literal>nic</literal>
        </term>
        <listitem>
          <para>
      Creates a new Network Interface Card (NIC) and connects it to a
      specified Virtual Local Area Network (VLAN). For more information, see
      <xref linkend="cha.qemu.running.networking.nic"/>.
     </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <literal>user</literal>
        </term>
        <listitem>
          <para>
      Specifies user-mode networking. For more information, see
      <xref linkend="cha.qemu.running.networking.usermode"/>.
     </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <literal>tap</literal>
        </term>
        <listitem>
          <para>
      Specifies bridged or routed networking. For more information, see
      <xref linkend="cha.qemu.running.networking.bridge"/>.
     </para>
        </listitem>
      </varlistentry>
    </variablelist>
    <sect2 xml:id="cha.qemu.running.networking.nic">
      <title>Defining a Network Interface Card</title>
      <para>
    Use <literal>-net nic</literal> to add a new emulated network card:
   </para>
      <screen>qemu-system-ARCH [...] -net nic,vlan=1<co xml:id="co.qemu.running.networking.nic.vlan"/>,macaddr=00:16:35:AF:94:4B<co xml:id="co.qemu.running.networking.nic.mac"/>,\
model=virtio<co xml:id="co.qemu.running.networking.nic.model"/>,name=ncard1<co xml:id="co.qemu.running.networking.nic.name"/> -net user</screen>
      <calloutlist>
        <callout arearefs="co.qemu.running.networking.nic.vlan">
          <para>
      Connects the network interface to VLAN number 1. You can specify your
      own number,—it is mainly useful for identification purpose. If you
      omit this suboption, QEMU uses the default 0.
     </para>
        </callout>
        <callout arearefs="co.qemu.running.networking.nic.mac">
          <para>
      Specifies the Media Access Control (MAC) address for the network card.
      It is a unique identifier and you are advised to always specify it. If
      not, QEMU supplies its own default MAC address and creates a
      possible MAC address conflict within the related VLAN.
     </para>
        </callout>
        <callout arearefs="co.qemu.running.networking.nic.model">
          <para>
      Specifies the model of the network card. Use <literal>-net
      nic,model=?</literal> to get the list of all network card models
      supported by QEMU on your platform:
     </para>
          <para>
      Currently, SUSE supports the models <literal>rtl8139</literal>,
      <literal>e1000</literal> and <literal>virtio</literal>.
     </para>
        </callout>
      </calloutlist>
    </sect2>
    <sect2 xml:id="cha.qemu.running.networking.usermode">
      <title>User-Mode Networking</title>
      <para>
    The <literal>-net user</literal> option instructs QEMU to use 
    user-mode networking. This is the default if no networking mode is
    selected. Therefore, these command lines are equivalent:
   </para>
      <screen>qemu-system-ARCH -hda /images/sles_base.raw</screen>
      <screen>qemu-system-ARCH -hda /images/sles_base.raw -net nic -net user</screen>
      <para>
    This mode is useful if you want to allow the VM Guest to access the
    external network resources, such as the Internet. By default, no incoming
    traffic is permitted and therefore, the VM Guest is not visible to
    other machines on the network. No administrator privileges are required
    in this networking mode. The user-mode is also useful  for doing a
    'network-booting' on your VM Guest from a local directory on VM Host Server.
   </para>
      <para>
    The VM Guest allocates an IP address from a virtual DHCP server.
    VM Host Server (the DHCP server) is reachable at 10.0.2.2, while the IP
    address range for allocation starts from 10.0.2.15. You can use
    <command>ssh</command> to connect to VM Host Server at 10.0.2.2, and
    <command>scp</command> to copy files back and forth.
   </para>
      <sect3 xml:id="cha.qemu.running.networking.usermode.examples">
        <title>Command Line Examples</title>
        <para>
     This section shows several examples on how to set up user-mode
     networking with QEMU.
    </para>
        <example xml:id="ex.qemu.net.usermode.resctrict">
          <title>Restricted User-mode Networking</title>
          <screen>qemu-system-ARCH [...] -net user<co xml:id="co.usermode.user"/>,vlan=1<co xml:id="co.usermode.vlan"/>,name=user_net1<co xml:id="co.usermode.name"/>,restrict=yes<co xml:id="co.usermode.restrict"/></screen>
          <calloutlist>
            <callout arearefs="co.usermode.user">
              <para>
        Specifies user-mode networking.
       </para>
            </callout>
            <callout arearefs="co.usermode.vlan">
              <para>
        Connects to VLAN number 1. If omitted, defaults to 0.
       </para>
            </callout>
            <callout arearefs="co.usermode.name">
              <para>
        Specifies a human-readable name of the network stack. Useful when
        identifying it in the QEMU monitor.
       </para>
            </callout>
            <callout arearefs="co.usermode.restrict">
              <para>
        Isolates VM Guest. It will not be able to communicate with VM Host Server
        and no network packets will be routed to the external network.
       </para>
            </callout>
          </calloutlist>
        </example>
        <example xml:id="ex.qemu.net.usermode.iprange">
          <title>User-mode Networking with Custom IP Range</title>
          <screen>qemu-system-ARCH [...] -net user,net=10.2.0.0/8<co xml:id="co.usermode.net"/>,host=10.2.0.6<co xml:id="co.usermode.host"/>,dhcpstart=10.2.0.20<co xml:id="co.usermode.dhcpstart"/>,\
hostname=tux_kvm_guest<co xml:id="co.usermode.hostname"/></screen>
          <calloutlist>
            <callout arearefs="co.usermode.net">
              <para>
        Specifies the IP address of the network that VM Guest sees and
        optionally the netmask. Default is 10.0.2.0/8.
       </para>
            </callout>
            <callout arearefs="co.usermode.host">
              <para>
        Specifies the VM Host Server IP address that VM Guest sees. Default is
        10.0.2.2.
       </para>
            </callout>
            <callout arearefs="co.usermode.dhcpstart">
              <para>
        Specifies the first of the 16 IP addresses that the built-in DHCP
        server can assign to VM Guest. Default is 10.0.2.15.
       </para>
            </callout>
            <callout arearefs="co.usermode.hostname">
              <para>
        Specifies the host name that the built-in DHCP server will assign to
        VM Guest.
       </para>
            </callout>
          </calloutlist>
        </example>
        <example xml:id="ex.qemu.net.usermode.netboot_tftp">
          <title>User-mode Networking with Network-boot and TFTP</title>
          <screen>qemu-system-ARCH [...] -net user,tftp=/images/tftp_dir<co xml:id="co.usermode.tftp"/>,bootfile=/images/boot/pxelinux.0<co xml:id="co.usermode.bootfile"/></screen>
          <calloutlist>
            <callout arearefs="co.usermode.tftp">
              <para>
        Activates a built-in TFTP (a file transfer protocol with the
        functionality of a very basic FTP) server. The files in the
        specified directory will be visible to a VM Guest as the root of a
        TFTP server.
       </para>
            </callout>
            <callout arearefs="co.usermode.bootfile">
              <para>
        Broadcasts the specified file as a BOOTP (a network protocol that
        offers an IP address and a network location of a boot image, often
        used in diskless workstations) file. When used together with
        <literal>tftp</literal>, the VM Guest can boot from network from
        the local directory on the host.
       </para>
            </callout>
          </calloutlist>
        </example>
        <example xml:id="ex.qemu.net.usermode.hostfwd">
          <title>User-mode Networking with Host Port Forwarding</title>
          <screen>qemu-system-ARCH [...] -net user,hostfwd=tcp::2222-:22</screen>
          <para>
      Forwards incoming TCP connections to the port 2222 on the host to the
      port 22 (<systemitem class="service">SSH</systemitem>) on VM Guest.
      If <systemitem class="daemon">sshd</systemitem> is running on
      VM Guest, enter
     </para>
          <screen>ssh qemu_host -p 2222</screen>
          <para>
      where <literal>qemu_host</literal> is the host name or IP address of
      the host system, to get a <systemitem class="daemon">SSH</systemitem>
      prompt from VM Guest.
     </para>
        </example>
      </sect3>
    </sect2>
    <sect2 xml:id="cha.qemu.running.networking.bridge">
      <title>Bridged Networking</title>
      <para>
    With the <literal>-net tap</literal> option, QEMU creates a network
    bridge by connecting the host TAP network device to a specified VLAN of
    VM Guest. Its network interface is then visible to the rest of the
    network. This method does not work by default and has to be explicitly
    specified.
   </para>
      <para>
    First, create a network bridge and add a VM Host Server physical network
    interface (usually <literal>eth0</literal>) to it:
   </para>
      <procedure>
        <step>
          <para>
      Start <guimenu>YaST Control Center</guimenu> and select <menuchoice><guimenu>Network
      Devices</guimenu><guimenu>Network Settings</guimenu></menuchoice>.
     </para>
        </step>
        <step>
          <para>
      Click <guimenu>Add</guimenu> and select <guimenu>Bridge</guimenu> from
      the <guimenu>Device Type</guimenu> drop-down list in the
      <guimenu>Hardware Dialog</guimenu> window. Click
      <guimenu>Next</guimenu>.
     </para>
        </step>
        <step>
          <para>
      Choose whether you need a dynamically or statically assigned IP
      address, and fill the related network settings if applicable.
     </para>
        </step>
        <step>
          <para>
      In the <guimenu>Bridged Devices</guimenu> pane, select the Ethernet
      device to add to the bridge.
     </para>
          <figure>
            <title>Configuring Network Bridge with YaST</title>
            <mediaobject>
              <imageobject role="fo">
                <imagedata fileref="qemu_yast_bridge_eth0.png" width="70%" format="PNG"/>
              </imageobject>
              <imageobject role="html">
                <imagedata fileref="qemu_yast_bridge_eth0.png" width="70%" format="PNG"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>
      Click <guimenu>Next</guimenu>. When asked about adapting an already
      configured device, click <guimenu>Continue</guimenu>.
     </para>
        </step>
        <step>
          <para>
      Click <guimenu>OK</guimenu> to apply the changes. Check if the bridge
      is created:
     </para>
          <screen><prompt role="user">tux &gt; </prompt> brctl show
bridge name bridge id          STP enabled  interfaces
br0         8000.001676d670e4  no           eth0</screen>
        </step>
      </procedure>
      <sect3>
        <title>Connecting to a Bridge Manually</title>
        <para>
     Use the following example script to connect VM Guest to the newly
     created bridge interface <literal>br0</literal>. Several commands in
     the script are run via the <command>sudo</command> mechanism because
     they require <systemitem class="username">root</systemitem> privileges.
    </para>
        <note>
          <para>
      Make sure the <systemitem>tunctl</systemitem> and
      <systemitem>bridge-utils</systemitem> packages are installed on the
      VM Host Server. If not, install them with <command>zypper in tunctl
      bridge-utils</command>.
     </para>
        </note>
        <screen>
#!/bin/bash
bridge=br0<co xml:id="co.qemu.net.bridge.br"/>
tap=$(sudo tunctl -u $(whoami) -b)<co xml:id="co.qemu.net.bridge.tap"/>
sudo ip link set $tap up<co xml:id="co.qemu.net.bridge.up"/>
sleep 1s<co xml:id="co.qemu.net.bridge.sleep"/>
sudo brctl addif $bridge $tap<co xml:id="co.qemu.net.bridge.br3"/>
qemu-system-ARCH -m 512 -hda /images/sles_base.raw \
-net nic,vlan=0,model=virtio,macaddr=00:16:35:AF:94:4B \
-net tap,vlan=0,ifname=$tap<co xml:id="co.qemu.net.bridge.ifname"/>,script=no<co xml:id="co.qemu.net.bridge.script"/>,downscript=no
sudo brctl delif $bridge $tap<co xml:id="co.qemu.net.bridge.delif"/>
sudo ip link set $tap down<co xml:id="co.qemu.net.bridge.linkdown"/>
sudo tunctl -d $tap<co xml:id="co.qemu.net.bridge.deltap"/></screen>
        <calloutlist>
          <callout arearefs="co.qemu.net.bridge.br">
            <para>
       Name of the bridge device.
      </para>
          </callout>
          <callout arearefs="co.qemu.net.bridge.tap">
            <para>
       Prepare a new TAP device and assign it to the user who runs the
       script. TAP devices are virtual network devices often used for
       virtualization and emulation setups.
      </para>
          </callout>
          <callout arearefs="co.qemu.net.bridge.up">
            <para>
       Bring up the newly created TAP network interface.
      </para>
          </callout>
          <callout arearefs="co.qemu.net.bridge.sleep">
            <para>
       Make a 1-second pause to make sure the new TAP network interface is
       really up.
      </para>
          </callout>
          <callout arearefs="co.qemu.net.bridge.br3">
            <para>
       Add the new <literal>TAP</literal> device to the network bridge
       <literal>br0</literal>.
      </para>
          </callout>
          <callout arearefs="co.qemu.net.bridge.ifname">
            <para>
       The <literal>ifname=</literal> suboption specifies the name of the
       TAP network interface used for bridging.
      </para>
          </callout>
          <callout arearefs="co.qemu.net.bridge.script">
            <para>
       Before <command>qemu-system-ARCH</command> connects to a network
       bridge, it checks the <literal>script</literal> and
       <literal>downscript</literal> values. If it finds the specified
       scripts on the VM Host Server file system, it runs the
       <literal>script</literal> before it connects to the network bridge
       and <literal>downscript</literal> after it exits the network
       environment. You can use these scripts to first set up and bring up
       the bridged network devices, and then to deconfigure them. By
       default, <filename>/etc/qemu-ifup</filename> and
       <filename>/etc/qemu-ifdown</filename> are examined. If
       <literal>script=no</literal> and <literal>downscript=no</literal> are
       specified, the script execution is disabled and you have to take care of
       it manually.
      </para>
          </callout>
          <callout arearefs="co.qemu.net.bridge.delif">
            <para>
       Deletes the TAP interface from a network bridge
       <literal>br0</literal>.
      </para>
          </callout>
          <callout arearefs="co.qemu.net.bridge.linkdown">
            <para>
       Sets the state of the TAP device to 'down'.
      </para>
          </callout>
          <callout arearefs="co.qemu.net.bridge.deltap">
            <para>
       Deconfigures the TAP device.
      </para>
          </callout>
        </calloutlist>
      </sect3>
      <sect3 xml:id="qemu.bridge.helper">
        <title>Connecting to a Bridge with qemu-bridge-helper</title>
        <para>
     Another way to connect VM Guest to a network through a network bridge
     is by means of the <filename>qemu-bridge-helper</filename> helper
     program. It configures the TAP interface for you, and attaches it to
     the specified bridge. The default helper executable is
     <filename>/usr/lib64/qemu-bridge-helper</filename>. The helper
     executable is setuid root, which is only executable by the members of
     the virtualization group (<literal>kvm</literal>). Therefore the
     <command>qemu-system-ARCH</command> command itself does not have to be
     run under <systemitem class="username">root</systemitem> privileges.
    </para>
        <para>
     You can call the helper the following way:
    </para>
        <screen>qemu-system-ARCH [...] -net nic,vlan=0,model=virtio -net bridge,vlan=0,br=br0</screen>
        <para>
     You can specify your own custom helper script that will take care of
     the TAP device (de)configuration, with the
     <option>helper=/path/to/your/helper</option> option:
    </para>
        <screen>qemu-system-ARCH [...] -net bridge,vlan=0,br=br1,helper=/path/to/bridge-helper</screen>
        <tip>
          <para>
      To define access privileges to <literal>qemu-bridge-helper</literal>,
      inspect the <filename>/etc/qemu-system-ARCH/bridge.conf</filename>
      file. For example the following directive
     </para>
          <screen>allow br0</screen>
          <para>
      allows the <command>qemu-system-ARCH</command> command to connect its
      VM Guest to the network bridge <literal>br0</literal>.
     </para>
        </tip>
      </sect3>
    </sect2>
    <sect2 xml:id="kvm.qemu.vnet">
      <title>Accelerated Networking with <systemitem>vhost-net</systemitem></title>
      <para>
    The <systemitem>vhost-net</systemitem> module is used to accelerate
    KVM's paravirtualized network drivers. It provides better latency and
    greater throughput for network.
   </para>
      <para>
    To make use of the module, verify that the host's running Kernel has
    <literal>CONFIG_VHOST_NET</literal> turned on or enabled as a module:
   </para>
      <screen>grep CONFIG_VHOST_NET /boot/config-`uname -r`</screen>
      <para>
    Also verify that the guest's running Kernel has
    <literal>CONFIG_PCI_MSI</literal> enabled:
   </para>
      <screen>grep CONFIG_PCI_MSI /boot/config-`uname -r`</screen>
      <para>
    If both conditions are met, use the <literal>vhost-net</literal> driver
    by starting the guest with the following example command line:
   </para>
      <screen>qemu-system-ARCH [...] -netdev tap,id=guest0,vhost=on,script=no
-net nic,model=virtio,netdev=guest0,macaddr=00:16:35:AF:94:4B</screen>
      <para>
    Note that <literal>guest0</literal> is an identification string of the
    vhost-driven device.
   </para>
    </sect2>
    <sect2 xml:id="kvm.qemu.multiqueue">
      <title>Scaling Network Performance with Multiqueue virtio-net</title>
      <para>
    As the number of virtual CPUs increases in VM Guests, QEMU offers a
    way of improving the network performance using
    <emphasis>multiqueue</emphasis>. Multiqueue virtio-net scales the
    network performance by allowing VM Guest virtual CPUs to transfer
    packets in parallel. Multiqueue support is required on both VM Host Server and
    VM Guest side.
   </para>
      <tip>
        <title>Performance Benefit</title>
        <para>
     The Multiqueue virtio-net solution is most beneficial in the following cases:
    </para>
        <itemizedlist>
          <listitem>
            <para>
       Network traffic packets are large.
      </para>
          </listitem>
          <listitem>
            <para>
       VM Guest has more connections active at the same time, mainly
       between the guest systems, or between the guest and the host, or
       between the guest and an external system.
      </para>
          </listitem>
          <listitem>
            <para>
       The number of active queues is equal to the number of virtual CPUs in
       the VM Guest.
      </para>
          </listitem>
        </itemizedlist>
      </tip>
      <note>
        <para>
     While multiqueue virtio-net increases the total network throughput, it
     increases CPU consumption as it makes use of the virtual CPU's power.
    </para>
      </note>
      <procedure xml:id="kvm.qemu.mq.enable">
        <title>How to Enable Multiqueue virtio-net</title>
        <para>
     The following procedure lists important steps to enable the multiqueue
     feature with <command>qemu-system-ARCH</command>. It assumes that a tap
     network device with multiqueue capability (supported since kernel
     version 3.8) is set up on the VM Host Server.
    </para>
        <step>
          <para>
      In <command>qemu-system-ARCH</command>, enable multiqueue for the tap
      device:
     </para>
          <screen>-netdev tap,vhost=on,queues=<replaceable>N</replaceable></screen>
          <para>
      where <literal>N</literal> stands for the number of queue pairs.
     </para>
        </step>
        <step>
          <para>
      In <command>qemu-system-ARCH</command>, enable multiqueue and specify
      MSI-X (Message Signaled Interrupt) vectors for the virtio-net-pci
      device:
     </para>
          <screen>-device virtio-net-pci,mq=on,vectors=<replaceable>2*N+2</replaceable></screen>
          <para>
      where the formula for the number of MSI-X vectors results from: N
      vectors for TX (transmit) queues, N for RX (receive) queues, one for
      configuration purposes, and one for possible VQ (vector quantization)
      control.
     </para>
        </step>
        <step>
          <para>
      In VM Guest, enable multiqueue on the relevant network interface
      (<literal>eth0</literal> in this example):
     </para>
          <screen>ethtool -L eth0 combined 2*N</screen>
        </step>
      </procedure>
      <para>
    The resulting <command>qemu-system-ARCH</command> command line will look
    similar to the following example:
   </para>
      <screen>qemu-system-ARCH [...] -netdev tap,id=guest0,queues=4,vhost=on \
-device virtio-net-pci,netdev=guest0,mq=on,vectors=10</screen>
      <para>
    Note that the <literal>id</literal> of the network device
    (<literal>guest0</literal> ) needs to be identical for both options.
   </para>
      <para>
    Inside the running VM Guest, specify the following command as <systemitem class="username">root</systemitem>:
   </para>
      <screen>ethtool -L eth0 combined 8</screen>
      <para>
    Now the guest system networking makes use of the multiqueue support from
    the <command>qemu-system-ARCH</command> hypervisor.
   </para>
    </sect2>
  </sect1>
  <sect1 xml:id="cha.qemu.running.vnc">
    <title>Viewing a VM Guest with VNC</title>
    <para>
   By default QEMU uses a GTK (a cross-platform toolkit library) window to
   display the graphical output of a VM Guest.
   <remark condition="clarity">
    2014-08-06 - fs: feedback from brogers: We should explain the "display
    xxx" command line syntax to present the various display options before
    diving into the vnc details.
   </remark>
   With the <literal>-vnc</literal> option specified, you can make QEMU
   listen on a specified VNC display and redirect its graphical output to
   the VNC session.
  </para>
    <tip>
      <para>
    When working with QEMU's virtual machine via VNC session, it is useful
    to work with the <literal>-usbdevice tablet</literal> option.
   </para>
      <para>
    Moreover, if you need to use another keyboard layout than the default
    <literal>en-us</literal>, specify it with the <literal>-k</literal>
    option.
   </para>
    </tip>
    <para>
   The first suboption of <literal>-vnc</literal> must be a
   <emphasis>display</emphasis> value. The <literal>-vnc</literal> option
   understands the following display specifications:
  </para>
    <variablelist>
      <varlistentry>
        <term>
          <literal>host:display</literal>
        </term>
        <listitem>
          <para>
      Only connections from <literal>host</literal> on the display number
      <literal>display</literal> will be accepted. The TCP port on which the
      VNC session is then running is normally a 5900 +
      <literal>display</literal> number. If you do not specify
      <literal>host</literal>, connections will be accepted from any host.
     </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <literal>unix:path</literal>
        </term>
        <listitem>
          <para>
      The VNC server listens for connections on Unix domain sockets. The
      <literal>path</literal> option specifies the location of the related
      Unix socket.
     </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <literal>none</literal>
        </term>
        <listitem>
          <para>
      The VNC server functionality is initialized, but the server itself is
      not started. You can start the VNC server later with the QEMU
      monitor. For more information, see <xref linkend="cha.qemu.monitor"/>.
     </para>
        </listitem>
      </varlistentry>
    </variablelist>
    <para>
   Following the display value there may be one or more option flags
   separated by commas. Valid options are:
  </para>
    <variablelist>
      <varlistentry>
        <term>
          <literal>reverse</literal>
        </term>
        <listitem>
          <para>
      Connect to a listening VNC client via a <emphasis>reverse</emphasis>
      connection.
     </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <literal>websocket</literal>
        </term>
        <listitem>
          <para>
      Opens an additional TCP listening port dedicated to VNC Websocket
      connections. By definition the Websocket port is 5700+display.
     </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <literal>password</literal>
        </term>
        <listitem>
          <para>
      Require that password-based authentication is used for client
      connections.
     </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <literal>tls</literal>
        </term>
        <listitem>
          <para>
      Require that clients use TLS when communicating with the VNC server.
     </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <literal>x509=/path/to/certificate/dir</literal>
        </term>
        <listitem>
          <para>
      Valid if TLS is specified. Require that x509 credentials are used for
      negotiating the TLS session.
     </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <literal>x509verify=/path/to/certificate/dir</literal>
        </term>
        <listitem>
          <para>
      Valid if TLS is specified. Require that x509 credentials are used for
      negotiating the TLS session.
     </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <literal>sasl</literal>
        </term>
        <listitem>
          <para>
      Require that the client uses SASL to authenticate with the VNC server.
     </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <literal>acl</literal>
        </term>
        <listitem>
          <para>
      Turn on access control lists for checking of the x509 client
      certificate and SASL party.
     </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <literal>lossy</literal>
        </term>
        <listitem>
          <para>
      Enable lossy compression methods (gradient, JPEG, ...).
     </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <literal>non-adaptive</literal>
        </term>
        <listitem>
          <para>
      Disable adaptive encodings. Adaptive encodings are enabled by default.
     </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <literal>share=[allow-exclusive|force-shared|ignore]</literal>
        </term>
        <listitem>
          <para>
      Set display sharing policy.
     </para>
        </listitem>
      </varlistentry>
    </variablelist>
    <note>
      <para>
    For more details about the display options, see the
    <emphasis>qemu-doc</emphasis> man page.
   </para>
    </note>
    <para>
   An example VNC usage:
  </para>
    <screen><prompt role="user">tux &gt; </prompt> qemu-system-ARCH [...] -vnc :5
(on the client:)
<prompt role="user">wilber &gt; </prompt>:~&gt; vinagre venus:5905 &amp;</screen>
    <figure>
      <title>QEMU VNC Session</title>
      <mediaobject>
        <imageobject role="fo">
          <imagedata fileref="qemu_sles_vnc.png" width="70%" format="PNG"/>
        </imageobject>
        <imageobject role="html">
          <imagedata fileref="qemu_sles_vnc.png" width="70%" format="PNG"/>
        </imageobject>
      </mediaobject>
    </figure>
    <sect2 xml:id="cha.qemu.running.vnc.secure">
      <title>Secure VNC Connections</title>
      <para>
    The default VNC server setup does not use any form of authentication. In
    the previous example, any user can connect and view the QEMU VNC
    session from any host on the network.
   </para>
      <para>
    There are several levels of security that you can apply to your VNC
    client/server connection. You can either protect your connection with a
    password, use x509 certificates, use SASL authentication, or even
    combine some of these authentication methods in one QEMU command.
   </para>
      <para>
    See <xref linkend="app.kvm.certificates"/> for more information about
    the x509 certificates generation. For more information about configuring
    x509 certificates on a VM Host Server and the client, see
    <xref linkend="sec.libvirt.connect.remote.tls"/> and
    <xref linkend="sec.libvirt.connect.remote.tls.client"/>.
   </para>
      <para>
    The Vinagre VNC viewer supports advanced authentication mechanisms.
    Therefore, it will be used to view the graphical output of VM Guest in
    the following examples. For this example, let us assume that the server
    x509 certificates <filename>ca-cert.pem</filename>,
    <filename>server-cert.pem</filename>, and
    <filename>server-key.pem</filename> are located in the
    <filename>/etc/pki/qemu</filename> directory on the host, while the
    client's certificates are distributed in the following locations on the
    client:
   </para>
      <simplelist>
        <member>
          <filename>/etc/pki/CA/cacert.pem</filename>
        </member>
        <member>
          <filename>/etc/pki/libvirt-vnc/clientcert.pem</filename>
        </member>
        <member>
          <filename>/etc/pki/libvirt-vnc/private/clientkey.pem</filename>
        </member>
      </simplelist>
      <example xml:id="ex.running.vnc.secure.pwd">
        <title>Password Authentication</title>
        <screen>qemu-system-ARCH [...] -vnc :5,password -monitor stdio</screen>
        <para>
     Starts the VM Guest graphical output on VNC display number 5 (usually
     port 5905). The <literal>password</literal> suboption initializes a
     simple password-based authentication method. There is no password set
     by default and you have to set one with the <command>change vnc
     password</command> command in QEMU monitor:
    </para>
        <screen>QEMU 2.0.0 monitor - type 'help' for more information
(qemu) change vnc password
Password: ****
</screen>
        <para>
     You need the <literal>-monitor stdio</literal> option here, because you
     would not be able to manage the QEMU monitor without redirecting its
     input/output.
    </para>
      </example>
      <figure>
        <title>Authentication Dialog in Vinagre</title>
        <mediaobject>
          <imageobject role="fo">
            <imagedata fileref="qemu_vnc_pwd.png" width="70%" format="PNG"/>
          </imageobject>
          <imageobject role="html">
            <imagedata fileref="qemu_vnc_pwd.png" width="70%" format="PNG"/>
          </imageobject>
        </mediaobject>
      </figure>
      <example xml:id="ex.running.vnc.secure.x509">
        <title>x509 Certificate Authentication</title>
        <para>
     The QEMU VNC server can use TLS encryption for the session and x509
     certificates for authentication. The server asks the client for a
     certificate and validates it against the CA certificate. Use this
     authentication type if your company provides an internal certificate
     authority.
    </para>
        <screen>qemu-system-ARCH [...] -vnc :5,tls,x509verify=/etc/pki/qemu</screen>
      </example>
      <example xml:id="ex.running.vnc.secure.pwd_x509">
        <title>x509 Certificate and Password Authentication</title>
        <para>
     You can combine the password authentication with TLS encryption and
     x509 certificate authentication to create a two-layer authentication
     model for clients. Remember to set the password in the QEMU monitor
     after you run the following command:
    </para>
        <screen>qemu-system-ARCH [...] -vnc :5,password,tls,x509verify=/etc/pki/qemu -monitor stdio</screen>
      </example>
      <example xml:id="ex.running.vnc.secure.sasl">
        <title>SASL Authentication</title>
        <para>
     Simple Authentication and Security Layer (SASL) is a framework for
     authentication and data security in Internet protocols. It integrates
     several authentication mechanisms, like PAM, Kerberos, LDAP and more.
     SASL keeps its own user database, so the connecting user accounts do
     not need to exist on VM Host Server.
    </para>
        <para>
     For security reasons, you are advised to combine SASL authentication
     with TLS encryption and x509 certificates:
    </para>
        <screen>qemu-system-ARCH [...] -vnc :5,tls,x509,sasl -monitor stdio</screen>
      </example>
    </sect2>
  </sect1>
  <sect1 xml:id="kvm.qemu.virtfs">
    <title>VirtFS: Sharing Folders between Host and Guests</title>
    <para>
   VM Guests usually run in a separate computing space—they are
   provided their own memory range, dedicated CPUs, and file system space.
   The ability to share parts of the VM Host Server's file system makes the
   virtualization environment more flexible by simplifying mutual data
   exchange. Network file systems, such as CIFS and NFS, have been the
   traditional way of sharing folders. But as they are not specifically
   designed for virtualization purposes, they suffer from major performance
   and feature issues.
  </para>
    <para>
   KVM introduces a new optimized method called
   <emphasis>VirtFS</emphasis> (sometimes referred to as a <quote>file
   system pass-through</quote>). VirtFS uses a paravirtual file system
   driver, which avoids converting the guest application file system
   operations into block device operations, and then again into host file
   system operations.
  </para>
    <para>
   You typically use VirtFS for the following situations:
  </para>
    <itemizedlist>
      <listitem>
        <para>
     To access a shared folder from several guests, or to provide
     guest-to-guest file system access.
    </para>
      </listitem>
      <listitem>
        <para>
     To replace the virtual disk as the root file system to which the guest's
     ramdisk connects during the guest boot process.
    </para>
      </listitem>
      <listitem>
        <para>
     To provide storage services to different customers from a single host file
     system in a cloud environment.
    </para>
      </listitem>
    </itemizedlist>
    <sect2 xml:id="kvm.qemu.virtfs.implement">
      <title>Implementation</title>
      <para>
    In QEMU, the implementation of VirtFS is facilitated by defining two
    types of devices:
   </para>
      <itemizedlist>
        <listitem>
          <para><literal>virtio-9p-pci</literal> device which transports protocol
      messages and data between the host and the guest.
     </para>
        </listitem>
        <listitem>
          <para><literal>fsdev</literal> device which defines the export file system
      properties, such as file system type and security model.
     </para>
        </listitem>
      </itemizedlist>
      <example xml:id="ex.qemu.virtfs.host">
        <title>Exporting Host's File System with VirtFS</title>
        <screen>qemu-system-ARCH [...] -fsdev local,id=exp1<co xml:id="co.virtfs.host.id"/>,path=/tmp/<co xml:id="co.virtfs.host.path"/>,security_model=mapped<co xml:id="co.virtfs.host.sec_model"/>
-device virtio-9p-pci,fsdev=exp1<co xml:id="co.virtfs.host.fsdev"/>,mount_tag=v_tmp<co xml:id="co.virtfs.host.mnt_tag"/></screen>
        <calloutlist>
          <callout arearefs="co.virtfs.host.id">
            <para>
       Identification of the file system to be exported.
      </para>
          </callout>
          <callout arearefs="co.virtfs.host.path">
            <para>
       File system path on the host to be exported.
      </para>
          </callout>
          <callout arearefs="co.virtfs.host.sec_model">
            <para>
       Security model to be used—<literal>mapped</literal> keeps the
       guest file system modes and permissions isolated from the host, while
       <literal>none</literal> invokes a <quote>pass-through</quote>
       security model in which permission changes on the guest's files are
       reflected on the host as well.
      </para>
          </callout>
          <callout arearefs="co.virtfs.host.fsdev">
            <para>
       The exported file system ID defined before with <literal>-fsdev
       id=</literal> .
      </para>
          </callout>
          <callout arearefs="co.virtfs.host.mnt_tag">
            <para>
       Mount tag used later on the guest to mount the exported file system.
      </para>
          </callout>
        </calloutlist>
        <para>
     Such an exported file system can be mounted on the guest like this
    </para>
        <screen>sudo mount -t 9p -o trans=virtio v_tmp /mnt</screen>
        <para>
     where <literal>v_tmp</literal> is the mount tag defined earlier with
     <literal>-device mount_tag=</literal> and <literal>/mnt</literal> is
     the mount point where you want to mount the exported file system.
    </para>
      </example>
    </sect2>
  </sect1>
  <sect1 xml:id="kvm.qemu.ksm">
    <title>KSM: Sharing Memory Pages between Guests</title>
    <para>
   Kernel SamePage Merging (<xref linkend="gloss.vt.acronym.ksm"/>) is a
   Linux Kernel feature that merges identical memory pages from multiple
   running processes into one memory region. Because KVM guests run as
   processes under Linux, <xref linkend="gloss.vt.acronym.ksm"/> provides
   the memory overcommit feature to hypervisors for more efficient use of
   memory. Therefore, if you need to run multiple virtual machines on a host
   with limited memory, <xref linkend="gloss.vt.acronym.ksm"/> may be
   helpful to you.
  </para>
    <para>
   For more information on the meaning of the
   <filename>/sys/kernel/mm/ksm/*</filename> files, see
   <filename>/usr/src/linux/Documentation/vm/ksm.txt</filename> (package
   <systemitem>kernel-source</systemitem>).
  </para>
    <!-- 
 aginies: 2014-08-29
 brogers remarks: 
 we shouldn't need to mention looking for whether such and such config option
 is enabled in the running kernel. We CONTROL the running kernel in this
 context 
  <para>
    To make use of <xref linkend="gloss.vt.acronym.ksm"/>, do the following.
  </para>
  <procedure>
   <step>
    <para>
     Verify that <xref linkend="gloss.vt.acronym.ksm"/> is enabled in your running Kernel:
    </para>
<screen>grep KSM /boot/config-`uname -r`
CONFIG_KSM=y</screen>
    <para>
     If <xref linkend="gloss.vt.acronym.ksm"/> is enabled in the running Kernel, you will see the following
     files under the <filename>/sys/kernel/mm/ksm</filename> directory:
    </para>

f.c.i.g bug with tag comment .... need to remove screen content....
 svn version r14426

   </step>
   <step>
    <para>
     Check if <xref linkend="gloss.vt.acronym.ksm"/> feature is turned on.
    </para>
<screen>cat /sys/kernel/mm/ksm/run</screen>
    <para>
     If the command returns <literal>0</literal>, turn <xref linkend="gloss.vt.acronym.ksm"/> on with
    </para>
<screen>sudo echo 1 > /sys/kernel/mm/ksm/run</screen>
   </step>
   <step>
    <para>
     Now run several &vmguest;s under &kvm; and inspect the content of files
     <filename>pages_sharing</filename> and
     <filename>pages_shared</filename>, for example:
    </para>
<screen>while [ 1 ]; do cat /sys/kernel/mm/ksm/pages_shared; sleep 1; done
13522
13523
13519
13518
13520
13520
13528</screen>
   </step>
  </procedure>
-->
  </sect1>
</chapter>
