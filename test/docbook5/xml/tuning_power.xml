<!-- Converted by db4-upgrade version 1.1 -->

<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:id="cha.tuning.power">
  <title>Power Management</title>
  <!--
 power management on the server (not mobile computers)
 Info Provider: Thomas Renniger <trenn@suse.de>
-->
  <sect1 xml:id="sec.tuning.power.cpu">
    <title>Power Management at CPU Level</title>
    <para>
   At the CPU level, you can control power usage in various ways. For
   example by using idling power states (C-states), changing CPU frequency
   (P-states), and throttling the CPU (T-states). The following sections
   give a short introduction to each approach and its significance for power
   savings. Detailed specifications can be found at
   <link xlink:href="http://www.acpi.info/spec.htm"/>.
  </para>
    <note>
      <title>Tickless Kernel</title>
      <para><phrase role="productname"><phrase os="osuse">openSUSE</phrase><phrase os="sles">SUSE Linux Enterprise Server</phrase><phrase os="sled">SUSE Linux Enterprise Desktop</phrase><phrase os="slerte">SUSE Linux Enterprise Real Time Extension</phrase></phrase> uses a tickless Kernel. Previous Kernels used to query the
    CPU at predetermined intervals (<quote>timer tick</quote>) about the
    processes currently being executed. These queries were done irrespective
    of the CPU power state and prevented the CPU from becoming idle and
    entering power saving states. A tickless Kernel only queries the CPU on
    demand, therefore allowing the CPU to remain idle and entering a power
    saving state.
   </para>
      <para>
    To restore the <quote>timer tick</quote> behavior, boot the system with
    the Kernel parameter <option>nohz=off</option>.
   </para>
    </note>
    <sect2 xml:id="sec.tuning.power.cpu.cstates">
      <title>C-States (Processor Operating States)</title>
      <para>
    Modern processors have several power saving modes called
    <literal>C-states</literal>. They reflect the capability of an idle
    processor to turn off unused components in order to save power. Whereas
    C-states have been available for laptops for some time, they are a more
    recent trend in the server market. For example, Intel* server processors
    have supported C-modes starting with the
    <phrase role="productname">Nehalem</phrase> architecture.
   </para>
      <para>
    When a processor is in the <literal>C0</literal> state, it is executing
    instructions. A processor running in any other C-state is idle. The
    higher the C number, the deeper the CPU sleep mode: more components are
    shut down to save power. Deeper sleep states can save large amounts of
    energy. Their downside is that they introduce latency. This means, it
    takes more time for the CPU to go back to <literal>C0</literal>).
    Depending on workload (threads waking up, triggering CPU usage and then
    going back to sleep again for a short period of time) and hardware (for
    example, interrupt activity of a network device), disabling the deepest
    sleep states can significantly increase overall performance. For details
    on how to do so, refer to
    <xref linkend="sec.tuning.power.tools.cpupower.idle-info"/>.
   </para>
      <para>
    Some states also have submodes with different power saving latency
    levels. Which C-states and submodes are supported depends on the
    respective processor. However, <literal>C1</literal> is always
    available.
   </para>
      <para><xref linkend="tab.tuning.power.cstates"/> gives an overview of the most
    common C-states.
   </para>
      <table xml:id="tab.tuning.power.cstates">
        <title>C-States</title>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>
                <para>
         Mode
        </para>
              </entry>
              <entry>
                <para>
         Definition
        </para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para>
         C0
        </para>
              </entry>
              <entry>
                <para>
         Operational state. CPU fully turned on.
        </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
         C1
        </para>
              </entry>
              <entry>
                <para>
         First idle state. Stops CPU main internal clocks via software. Bus
         interface unit and APIC are kept running at full speed.
         <remark>sknorr, 2014-08-21: Definition of APIC?</remark><!--taroth 2010-04-28: upon request by trenn, do
          not mention C1E at all--><!--Some processors
         also support an Enhanced C1 state (C1E or Enhanced Halt State) for
         lower power consumption. --></para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
         C2
        </para>
              </entry>
              <entry>
                <para>
         Stops CPU main internal clocks via hardware. State in which the
         processor maintains all software-visible states, but may take
         longer to wake up through interrupts.
        </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
         C3
        </para>
              </entry>
              <entry>
                <para>
         Stops all CPU internal clocks. The processor does not need to keep
         its cache coherent, but maintains other states. Some processors
         have variations of the C3 state that differ in how long it takes to
         wake the processor through interrupts.
        </para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>
    To avoid needless power consumption, it is recommended to test your
    workloads with deep sleep states enabled versus deep sleep states
    disabled.
    <remark>sknorr, 2014-08-21: some information about SLE 11 SP 3 commented
     out below. Can this go completely?</remark><!--A recent maintenance update for &productname; 11 SP3 provides an updated <systemitem
     class="resource">cpupower</systemitem> package with an additional
    <command>cpupower</command> subcommand. Use it to disable or enable
    individual C-states, if necessary.-->
    For more information, refer to
    <xref linkend="sec.tuning.power.tools.cpupower.idle-info"/> or the
    <command>cpupower-idle-set(1)</command> man page.
   </para>
      <!--taroth 2010-04-28: upon request by trenn, do not mention C1E at all-->
      <!--<para>Whereas states C0 to C3 cut clock signals used inside the CPU, there are also
    C-states that work by reducing the CPU voltage (C4 to C6). <literal>Enhanced</literal> modes can
    do both at the same time. For example, C1E tries to provide more power savings than the
    traditional C1 state by also lowering the voltage and frequency. In fact, C1E has the ability to
    lower the voltage/frequency faster than any of the &cpufreq; governors discussed in <xref
    linkend="sec.tuning.power.cpufreq"/>. </para>-->
      <!--taroth 2010-08-02: from pcmcia-apm.xml: add for next revision:
  <para>The current state is displayed in <filename>/proc/acpi/processor/*/power</filename>.</para>-->
    </sect2>
    <sect2 xml:id="sec.tuning.power.cpu.pstates">
      <title>P-States (Processor Performance States)</title>
      <para>
    While a processor operates (in C0 state), it can be in one of several
    CPU performance states <literal>(P-states)</literal>. Whereas C-states
    are idle states (all but C0), <literal>P-states</literal> are
    operational states that relate to CPU frequency and voltage.
   </para>
      <para>
    The higher the P-state, the lower the frequency and voltage at which the
    processor runs. The number of P-states is processor-specific and the
    implementation differs across the various types. However,
    <literal>P0</literal> is always the highest-performance state. Higher
    P-state numbers represent slower processor speeds and lower power
    consumption. For example, a processor in <literal>P3</literal> state run
    more slowly and uses less power than a processor running in the
    <literal>P1</literal> state. To operate at any P-state, the processor
    must be in the <literal>C0</literal> state, which means that it is
    working and not idling. The CPU P-states are also defined in the ACPI
    specification, see <link xlink:href="http://www.acpi.info/spec.htm"/>.
   </para>
      <para>
    C-states and P-states can vary independently of one another.
   </para>
    </sect2>
    <sect2 xml:id="sec.tuning.cpu.power.tstates">
      <title>T-States (Processor Throttling States)</title>
      <para>
    T-states refer to throttling the processor clock to lower frequencies in
    order to reduce thermal effects. This means that the CPU is forced to be
    idle a fixed percentage of its cycles per second. Throttling states
    range from <literal>T1</literal> (the CPU has no forced idle cycles) to
    <literal>T<replaceable>n</replaceable></literal>, with the percentage of
    idle cycles increasing the greater <replaceable>n</replaceable> is.
   </para>
      <para>
    However, throttling does not reduce voltage. Also, since the CPU is
    forced to idle part of the time, processes will take longer to finish
    and will consume more power.
   </para>
      <para>
    T-states are only useful if reducing thermal effects is the primary
    goal. Since T-states can interfere with C-states (preventing the CPU
    from reaching higher C-states), they can even increase power consumption
    in a modern CPU capable of C-states.
   </para>
      <!--taroth 2010-0802: from pcmcia-apm.xml, perhaps add for next revision:
   <para>The system interface is <filename>/proc/acpi/processor/*/throttling</filename>.</para>-->
    </sect2>
    <sect2 xml:id="sec.tuning.cpu.power.turbo">
      <title>Turbo Features</title>
      <!--taroth 2011-09-22: terminology: AMD: Turbo CORE, Intel: Turbo Boost-->
      <para>
    Modern processors use a combination of different means to achieve a
    balance between performance and power savings: deep sleep states,
    traditional dynamic frequency scaling and hidden boost frequencies.
    Newer AMD* and Intel* CPUs have turbo features (Turbo CORE* and Turbo
    Boost*, respectively). Turbo features allow dynamically increasing the
    clock speed of active CPU cores while other cores are in deep sleep
    states. This increases the performance of active threads while still
    complying with Thermal Design Power (TDP) limits.
   </para>
      <para>
    However, the conditions under which a CPU core can use turbo frequencies
    are architecture-specific. Learn how to evaluate the efficiency of those
    new features in <xref linkend="sec.tuning.power.tools.cpupower"/>.
   </para>
    </sect2>
  </sect1>
  <sect1 xml:id="sec.tuning.power.cpufreq">
    <title>The Linux Kernel CPUfreq Infrastructure</title>
    <!--relates to P-States-->
    <para>
   Processor performance states (P-states) and processor operating states
   (C-states) are the capability of a processor to switch between different
   supported operating frequencies and voltages to modulate power
   consumption.
  </para>
    <para>
   To dynamically scale processor frequencies at runtime, you can use the
   CPUfreq infrastructure to set a static or dynamic power policy for the
   system. Its main components are:
  </para>
    <itemizedlist>
      <listitem>
        <para>
     The CPUfreq subsystem, which provides a common interface to various
     low-level technologies and high-level policies.
    </para>
      </listitem>
      <listitem>
        <para>
     In-kernel governors, which are policy governors that can change the CPU
     frequency based on different criteria.
    </para>
      </listitem>
      <listitem>
        <para>
     CPU-specific drivers that implement the technology for a particular
     type of processor.
    </para>
      </listitem>
    </itemizedlist>
    <para>
   The dynamic scaling of the clock speed helps to consume less power and
   generate less heat when not operating at full capacity.
  </para>
    <sect2 xml:id="sec.tuning.power.cpufreq.governors">
      <title>In-Kernel Governors</title>
      <para>
    You can think of the in-kernel governors as a sort of preconfigured
    power scheme for the CPU. The CPUfreq governors use P-states to change
    frequencies and lower power consumption. The dynamic governors can
    switch between CPU frequencies, based on CPU usage, to allow for power
    savings while not sacrificing performance. These governors also allow
    for some tuning so you can customize and change the frequency scaling
    behavior.
   </para>
      <para>
    The following governors are available with the CPUfreq subsystem:
   </para>
      <variablelist>
        <varlistentry>
          <term>Performance Governor</term>
          <listitem>
            <para>
       The CPU frequency is statically set to the highest possible for
       maximum performance. Consequently, saving power is not the focus of
       this governor.
      </para>
            <para>
       Tuning options: The range of maximum frequencies available to the
       governor can be adjusted (for example, with the
       <command>cpupower</command> command line tool).
      </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Powersave Governor</term>
          <listitem>
            <para>
       The CPU frequency is statically set to the lowest possible. This can
       have severe impact on the performance, as the system will never rise
       above this frequency no matter how busy the processors are.
      </para>
            <para>
       However, using this governor often does not lead to the expected
       power savings as the highest savings can usually be achieved at idle
       through entering C-states. With the powersave governor, processes run
       at the lowest frequency and thus take longer to finish. This means it
       takes longer until the system can go into an idle C-state.
      </para>
            <para>
       Tuning options: The range of minimum frequencies available to the
       governor can be adjusted (for example, with the
       <command>cpupower</command> command line tool).
      </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>On-demand Governor</term>
          <listitem>
            <para>
       The kernel implementation of a dynamic CPU frequency policy: The
       governor monitors the processor usage. As soon as it exceeds a
       certain threshold, the governor will set the frequency to the highest
       available. If the usage is less than the threshold, the next lowest
       frequency is used. If the system continues to be underemployed, the
       frequency is again reduced until the lowest available frequency is
       set.
      </para>
            <para>
       For SUSE Linux Enterprise, the on-demand governor is the default governor and the one
       that has the best test coverage.
      </para>
            <para>
       Tuning options: The range of available frequencies, the rate at which
       the governor checks usage, and the usage threshold can be adjusted.
       Another parameter you might want to change for the on-demand governor
       is <literal>ignore_nice_load</literal>. For details, refer to
       <xref linkend="pro.tuning.power.t-states.ignore.nice"/>.
      </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Conservative Governor</term>
          <listitem>
            <para>
       Similar to the on-demand implementation, this governor also
       dynamically adjusts frequencies based on processor usage, except that
       it allows for a more gradual increase in power. If processor usage
       exceeds a certain threshold, the governor does not immediately switch
       to the highest available frequency (as the on-demand governor does),
       but only to next higher frequency available.
      </para>
            <para>
       Tuning options: The range of available frequencies, the rate at which
       the governor checks usage, the usage thresholds, and the frequency
       step rate can be adjusted.
      </para>
          </listitem>
        </varlistentry>
      </variablelist>
      <!-- taroth 2010-04-16: userspace governor is no longer supported by us, according to
    trenn-->
    </sect2>
    <sect2 xml:id="sec.tuning.power.cpufreq.files">
      <title>Related Files and Directories</title>
      <para>
    If the CPUfreq subsystem in enabled on your system (which it is by
    default with SUSE Linux Enterprise Server), you can find the relevant files and directories
    under <filename>/sys/devices/system/cpu/</filename>. If you list the
    contents of this directory, you will find a
    <filename>cpu{0..x}</filename> subdirectory for each processor, and
    several other files and directories. A <filename>cpufreq</filename>
    subdirectory in each processor directory holds a number of files and
    directories that define the parameters for CPUfreq. Some of them are
    writable (for <systemitem class="username">root</systemitem>), some of them are read-only. If your system
    currently uses the on-demand or conservative governor, you will see a
    separate subdirectory for those governors in
    <filename>cpufreq</filename>, containing the parameters for the
    governors.
   </para>
      <note>
        <title>Different Processor Settings</title>
        <para>
     The settings under the <filename>cpufreq</filename> directory can be
     different for each processor. If you want to use the same policies
     across all processors, you need to adjust the parameters for each
     processor. Instead of looking up or modifying the current settings
     manually (in <filename>/sys/devices/system/cpu*/cpufreq</filename>), we
     advise to use the tools provided by the
     <systemitem class="resource">cpupower</systemitem> package or by
     the older <systemitem class="resource">cpufrequtils</systemitem>
     package for that.
    </para>
      </note>
    </sect2>
  </sect1>
  <sect1 xml:id="sec.tuning.power.tools">
    <title>Viewing, Monitoring and Tuning Power-related Settings</title>
    <para>
   The following command line tools are available for that purpose:
  </para>
    <variablelist>
      <varlistentry>
        <term>
          <xref linkend="sec.tuning.power.tools.cpufrequtils" xrefstyle="select:title"/>
        </term>
        <listitem>
          <para>
      With the tools of the
      <systemitem class="resource">cpufrequtils</systemitem> package you can
      view and modify settings of the kernel-related CPUfreq subsystem.
      The <command>cpufreq*</command> commands are useful for modifying
      settings related to P-states, especially frequency scaling and
      CPUfreq governors.
     </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <xref linkend="sec.tuning.power.tools.cpupower" xrefstyle="select:title"/>
        </term>
        <listitem>
          <para>
      The new <command>cpupower</command> tool was designed to give an
      overview of <emphasis>all</emphasis> CPU power-related parameters that
      are supported on a given machine, including turbo (or boost) states.
      Use the tool set to view and modify settings of the kernel-related
      CPUfreq and cpuidle systems as well as other settings not related to
      frequency scaling or idle states. The integrated monitoring framework
      can access both kernel-related parameters and hardware statistics and
      is thus ideally suited for performance benchmarks. It also helps you
      to identify the dependencies between turbo and idle states.
     </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <xref linkend="sec.tuning.power.tools.powertop" xrefstyle="select:title"/>
        </term>
        <listitem>
          <para>
      powerTOP combines various sources of information and shows them in
      one screen, such as:
     </para>
          <itemizedlist>
            <listitem>
              <para>
        Analysis of programs, device drivers, and kernel options.
       </para>
            </listitem>
            <listitem>
              <para>
        Amounts and sources of interrupts waking up processors from sleep
        states.
       </para>
            </listitem>
          </itemizedlist>
          <para>
      The tool helps you identify the reasons for high power consumption,
      for example, processes that are mainly responsible for waking up a
      processor from its idle state. It also lets you optimize your system
      settings to avoid these.
     </para>
        </listitem>
      </varlistentry>
    </variablelist>
    <sect2 xml:id="sec.tuning.power.tools.cpufrequtils">
      <title>Using the <systemitem class="resource">cpufrequtils</systemitem> Tools</title>
      <note>
        <title><command>cpupower</command> and <command>cpufrequtils</command></title>
        <para>
     All functions of <command>cpufrequtils</command> are also covered by
     <command>cpupower</command>—a new set of tools that is more
     powerful and provides additional features. As
     <command>cpupower</command> will replace
     <command>cpufrequtils</command> sooner or later, we advise to switch to
     <command>cpupower</command> soon and to adjust your scripts
     accordingly.
    </para>
      </note>
      <para>
    After you have installed the
    <systemitem class="resource">cpufrequtils</systemitem> package,
    you can make use of the <command>cpufreq-info</command> and
    <command>cpufreq-set</command> command line tools.
   </para>
      <sect3 xml:id="sec.tuning.power.tools.cpufreq-info">
        <title>Viewing Current Settings with <command>cpufreq-info</command></title>
        <para>
     The <command>cpufreq-info</command> command helps you to retrieve
     CPUfreq kernel information. Run without any options, it collects the
     information available for your system:
    </para>
        <example>
          <title>Example Output of <command>cpufreq-info</command></title>
          <screen><?dbsuse-fo font-size="0.63em"?>cpufrequtils 004: cpufreq-info (C) Dominik Brodowski 2004-2006
Report errors and bugs to http://bugs.opensuse.org, please.
analyzing CPU 0:
  driver: acpi-cpufreq
  CPUs which need to switch frequency at the same time: 0
  hardware limits: 2.80 GHz - 3.40 GHz
  available frequency steps: 3.40 GHz, 2.80 GHz
  available cpufreq governors: conservative, userspace, powersave, ondemand, performance
  current policy: frequency should be within 2.80 GHz and 3.40 GHz.
                  The governor "performance" may decide which speed to use
                  within this range.
  current CPU frequency is 3.40 GHz.
analyzing CPU 1:
 driver: acpi-cpufreq
 CPUs which need to switch frequency at the same time: 1
 hardware limits: 2.80 GHz - 3.40 GHz
 available frequency steps: 3.40 GHz, 2.80 GHz
 available cpufreq governors: conservative, userspace, powersave, ondemand, performance
 current policy: frequency should be within 2.80 GHz and 3.40 GHz.
                 The governor "performance" may decide which speed to use
                 within this range.
current CPU frequency is 3.40 GHz.
    </screen>
        </example>
        <para>
     Using the appropriate options, you can view the current CPU frequency,
     the minimum and maximum CPU frequency allowed, show the currently used
     CPUfreq policy, the available CPUfreq governors, or determine the
     CPUfreq kernel driver used. For more details and the available
     options, refer to the <command>cpufreq-info</command> man page or run
     <command>cpufreq-info <option>--help</option></command>.
    </para>
      </sect3>
      <sect3 xml:id="sec.tuning.power.tools.cpufreq-set">
        <title>Modifying Current Settings with <command>cpufreq-set</command></title>
        <para>
     To modify CPUfreq settings, use the <command>cpufreq-set</command>
     command as <systemitem class="username">root</systemitem>. It allows you set values for the minimum or
     maximum CPU frequency the governor may select or to create a new
     governor. With the <option>-c</option> option, you can also specify for
     which of the processors the settings should be modified. That makes it
     easy to use a consistent policy across all processors without adjusting
     the settings for each processor individually. For more details and the
     available options, refer to the <command>cpufreq-set</command> man page
     or run <command>cpufreq-set <option>--help</option></command>.
    </para>
      </sect3>
    </sect2>
    <sect2 xml:id="sec.tuning.power.tools.cpupower">
      <title>Using the <systemitem class="resource">cpupower</systemitem> Tools</title>
      <para>
    After installing the
    <systemitem class="resource">cpupower</systemitem> package, view
    the available <command>cpupower</command> subcommands with
    <command>cpupower --help</command>. Access the general man page
    with <command>man cpupower</command>, and the man pages of the
    subcommands with
    <command>man cpupower-<replaceable>subcommand</replaceable></command>.
   </para>
      <para>
    The subcommands <command>frequency-info</command> and
    <command>frequency-set</command> are mostly equivalent to
    <command>cpufreq-info</command> and <command>cpufreq-set</command>,
    respectively. However, they provide extended output and there are small
    differences in syntax and behavior:
   </para>
      <itemizedlist>
        <title>Syntax Differences Between <command>cpufreq*</command> and <command>cpupower</command></title>
        <listitem>
          <para>
      To specify the number of the CPU to which the command is applied, both
      commands have the <option>-c</option> option. Because of the
      command-subcommand structure, the placement of the <option>-c</option>
      option is different for <command>cpupower</command>:
     </para>
          <para><command>cpupower -c 4 frequency-info</command> (versus
      <command>cpufreq-info -c 4</command>)
     </para>
          <para><command>cpupower</command> lets you also specify a list of CPUs with
      <option>-c</option>. For example, the following command would affect
      the CPUs <literal>1</literal> , <literal>2</literal>,
      <literal>3</literal>, and <literal>5</literal>:
     </para>
          <para>
            <command>cpupower -c 1-3,5 frequency-set</command>
          </para>
        </listitem>
        <listitem>
          <para>
      If <command>cpufreq*</command> and <command>cpupower</command> are
      used without the <option>-c</option> option, the behavior differs:
     </para>
          <para><command>cpufreq-set</command> automatically applies the command to
      CPU <literal>0</literal>, whereas
      <command>cpupower frequency-set</command> applies the command to
      all CPUs in this case. Typically, <command>cpupower *info</command>
      subcommands access only CPU <literal>0</literal>, whereas
      <command>cpufreq-info</command> accesses all CPUs, if not specified
      otherwise.
     </para>
        </listitem>
      </itemizedlist>
      <sect3 xml:id="sec.tuning.power.tools.cpupower.freq-info">
        <title>Viewing Current Settings with <command>cpupower</command></title>
        <para>
     Similar to <command>cpufreq-info</command>,
     <command>cpupower frequency-info</command> also shows the
     statistics of the cpufreq driver used in the Kernel. Additionally, it
     shows if turbo (boost) states are supported and enabled in the BIOS.
     Run without any options, it shows an output similar to the following:
    </para>
        <example>
          <title>Example Output of <command>cpupower frequency-info</command></title>
          <screen><?dbsuse-fo font-size="0.63em"?>analyzing CPU 0:
  driver: acpi-cpufreq
  CPUs which run at the same hardware frequency: 0 1 2 3
  CPUs which need to have their frequency coordinated by software: 0
  maximum transition latency: 10.0 us.
  hardware limits: 2.00 GHz - 2.83 GHz
  available frequency steps: 2.83 GHz, 2.34 GHz, 2.00 GHz
  available cpufreq governors: conservative, userspace, powersave, ondemand, performance
  current policy: frequency should be within 2.00 GHz and 2.83 GHz.
                  The governor "ondemand" may decide which speed to use
                  within this range.
  current CPU frequency is 2.00 GHz (asserted by call to hardware).
  boost state support:
    Supported: yes
    Active: yes
    </screen>
        </example>
        <para>
     To get the current values for all CPUs, use
     <command>cpupower -c all frequency-info</command>.
    </para>
      </sect3>
      <sect3 xml:id="sec.tuning.power.tools.cpupower.idle-info">
        <title>Viewing and Modifying Kernel Idle Statistics with <command>cpupower</command></title>
        <para>
     The <command>idle-info</command> subcommand shows the statistics of the
     cpuidle driver used in the Kernel. It works on all architectures that
     use the cpuidle Kernel framework.
    </para>
        <!-- taroth 2011-08-16: this is the output from my desktop machine, maybe
     ask trenn for output by a server machine-->
        <example>
          <title>Example Output of <command>cpupower idle-info</command></title>
          <screen>CPUidle driver: acpi_idle
CPUidle governor: menu

Analyzing CPU 0:
Number of idle states: 3
Available idle states: C1 C2
C1:
Flags/Description: ACPI FFH INTEL MWAIT 0x0
Latency: 1
Usage: 3156464
Duration: 233680359
C2:
Flags/Description: ACPI FFH INTEL MWAIT 0x10
Latency: 1
Usage: 273007117
Duration: 103148860538</screen>
        </example>
        <para>
     After finding out which processor idle states are supported with
     <command>cpupower idle-info</command>, individual states can be
     disabled using the <command>cpupower idle-set</command> command.
     Typically one wants to disable the deepest sleep state, for example:
    </para>
        <screen>cpupower idle-set -d 4</screen>
        <para>
     But before making this change permanent by adding the corresponding
     command to a current <filename>/etc/init.d/*</filename><remark>taroth 2014-03-10: FIXME -
      SYSTEMD</remark>
     service file, check for performance or power impact.
    </para>
      </sect3>
      <sect3 xml:id="sec.tuning.power.tools.cpupower.monitor">
        <title>Monitoring Kernel and Hardware Statistics with <command>cpupower</command></title>
        <para>
     The most powerful enhancement is the <command>monitor</command>
     subcommand. Use it to report processor topology, and monitor frequency
     and idle power state statistics over a certain period of time. The
     default interval is <literal>1</literal> second, but it can be changed
     with the <option>-i</option>. Independent processor sleep states and
     frequency counters are implemented in the tool—some retrieved
     from kernel statistics, others reading out hardware registers. The
     available monitors depend on the underlying hardware and the system.
     List them with <command>cpupower monitor -l</command>. For a
     description of the individual monitors, refer to the cpupower-monitor
     man page.
    </para>
        <para>
     The <command>monitor</command> subcommand allows you to execute
     performance benchmarks and to compare Kernel statistics with hardware
     statistics for specific workloads.
    </para>
        <example xml:id="ex.cpupower.monitor">
          <title>Example <command>cpupower monitor</command> Output</title>
          <screen>|Mperf               || Idle_Stats
 <co xml:id="co.cpupower.mon.mperf"/>                      <co xml:id="co.cpupower.mon.idle"/> 
CPU | C0   | Cx   | Freq || POLL | C1   | C2   | C3
   0|  3.71| 96.29|  2833||  0.00|  0.00|  0.02| 96.32
   1| 100.0| -0.00|  2833||  0.00|  0.00|  0.00|  0.00
   2|  9.06| 90.94|  1983||  0.00|  7.69|  6.98| 76.45
   3|  7.43| 92.57|  2039||  0.00|  2.60| 12.62| 77.52
     </screen>
          <calloutlist>
            <callout arearefs="co.cpupower.mon.mperf">
              <para>
        Mperf shows the average frequency of a CPU, including boost
        frequencies, over a period of time. Additionally, it shows the
        percentage of time the CPU has been active (<literal>C0</literal>)
        or in any sleep state (<literal>Cx</literal>). The default sampling
        rate is <literal>1</literal> second and the values are read directly
        from the hardware registers. As the turbo states are managed by the
        BIOS, it is impossible to get the frequency values at a given
        instant. On modern processors with turbo features the Mperf monitor
        is the only way to find out about the frequency a certain CPU has
        been running in.
       </para>
            </callout>
            <callout arearefs="co.cpupower.mon.idle">
              <para>
        Idle_Stats shows the statistics of the cpuidle kernel subsystem. The
        kernel updates these values every time an idle state is entered or
        left. Therefore there can be some inaccuracy when cores are in an
        idle state for some time when the measure starts or ends.
       </para>
            </callout>
          </calloutlist>
          <para>
      Apart from the (general) monitors in the example above, other
      architecture-specific monitors are available. For detailed
      information, refer to the <command>cpupower-monitor</command> man
      page.
     </para>
        </example>
        <para>
     By comparing the values of the individual monitors, you can find
     correlations and dependencies and evaluate how well the power saving
     mechanism works for a certain workload. In
     <xref linkend="ex.cpupower.monitor" xrefstyle="select:label"/> you can
     see that CPU <literal>0</literal> is idle (the value of
     <literal>Cx</literal> is near 100%), but runs at a very high frequency.
     Additionally, the CPUs <literal>0</literal> and <literal>1</literal>
     have the same frequency values which means that there is a dependency
     between them.
    </para>
      </sect3>
      <sect3 xml:id="sec.tuning.power.tools.cpupower.freq-set">
        <title>Modifying Current Settings with <command>cpupower</command></title>
        <para>
     Similar to <command>cpufreq-set</command>, you can use
     <command>cpupower frequency-set</command> command as <systemitem class="username">root</systemitem> to
     modify current settings. It allows you to set values for the minimum or
     maximum CPU frequency the governor may select or to create a new
     governor. With the <option>-c</option> option, you can also specify for
     which of the processors the settings should be modified. That makes it
     easy to use a consistent policy across all processors without adjusting
     the settings for each processor individually. For more details and the
     available options, refer to the
     <command>cpupower-freqency-set</command> man page or run
     <command>cpupower frequency-set <option>--help</option></command>.
    </para>
      </sect3>
    </sect2>
    <sect2 xml:id="sec.tuning.power.tools.powertop">
      <title>Monitoring Power Consumption with powerTOP</title>
      <para>
    Another useful tool for monitoring system power consumption is
    powerTOP. It helps you to identify the reasons for unnecessary high
    power consumption (for example, processes that are mainly responsible
    for waking up a processor from its idle state) and to optimize your
    system settings to avoid these. It supports both Intel and AMD
    processors. The <systemitem class="resource">powertop</systemitem>
    package is available from the SUSE Linux Enterprise SDK. For information on how to
    access the SDK, refer to <xref linkend="preface.tuning"/>.
   </para>
      <para>
    powerTOP combines various sources of information (analysis of
    programs, device drivers, kernel options, amounts and sources of
    interrupts waking up processors from sleep states) and shows them in one
    screen. <xref linkend="ex.tuning.power.powertop"/> shows which
    information categories are available:
   </para>
      <example xml:id="ex.tuning.power.powertop">
        <title>Example powerTOP Output</title>
        <screen>Cn               Avg  residency       P-states   (frequencies)
<co xml:id="co.powertop.cstates"/>                 <co xml:id="co.powertop.avg"/>      <co xml:id="co.powertop.residency"/>              <co xml:id="co.powertop.pstates"/>            <co xml:id="co.powertop.freq"/>
C0 (cpu running)        (11.6%)       2.00 Ghz       0.1%
polling         0.0ms   ( 0.0%)       2.00 Ghz       0.0%
C1              4.4ms   (57.3%)       1.87 Ghz       0.0%
C2             10.0ms   (31.1%)       1064 Mhz      99.9%


Wakeups-from-idle per second : 11.2     interval: 5.0s <co xml:id="co.powertop.wakeups"/>
no ACPI power usage estimate available <co xml:id="co.powertop.power"/>
<?dbsuse-fo font-size="0.7em"?>
Top causes for wakeups: <co xml:id="co.powertop.culprits"/>
96.2% (826.0)       &lt;interrupt&gt; : extra timer interrupt
 0.9% (  8.0)     &lt;kernel core&gt; : usb_hcd_poll_rh_status (rh_timer_func)
 0.3% (  2.4)       &lt;interrupt&gt; : megasas
 0.2% (  2.0)     &lt;kernel core&gt; : clocksource_watchdog (clocksource_watchdog)
 0.2% (  1.6)       &lt;interrupt&gt; : eth1-TxRx-0
 0.1% (  1.0)       &lt;interrupt&gt; : eth1-TxRx-4

[...]

Suggestion: <co xml:id="co.powertop.suggestions"/> Enable SATA ALPM link power management via:
echo min_power &gt; /sys/class/scsi_host/host0/link_power_management_policy
or press the S key.</screen>
        <calloutlist>
          <callout arearefs="co.powertop.cstates">
            <para>
       The column shows the C-states. When working, the CPU is in state
       <literal>0</literal>, when resting it is in some state greater than
       <literal>0</literal>, depending on which C-states are available and
       how deep the CPU is sleeping.
      </para>
          </callout>
          <callout arearefs="co.powertop.avg">
            <para>
       The column shows average time in milliseconds spent in the particular
       C-state.
      </para>
          </callout>
          <callout arearefs="co.powertop.residency">
            <para>
       The column shows the percentages of time spent in various C-states.
       For considerable power savings during idle, the CPU should be in
       deeper C-states most of the time. In addition, the longer the average
       time spent in these C-states, the more power is saved.
      </para>
          </callout>
          <callout arearefs="co.powertop.pstates">
            <para>
       The column shows the frequencies the processor and kernel driver
       support on your system.
      </para>
          </callout>
          <callout arearefs="co.powertop.freq">
            <para>
       The column shows the amount of time the CPU cores stayed in different
       frequencies during the measuring period.
      </para>
          </callout>
          <callout arearefs="co.powertop.wakeups">
            <para>
       Shows how often the CPU is awoken per second (number of interrupts).
       The lower the number, the better. The <literal>interval</literal>
       value is the powerTOP refresh interval which can be controlled with
       the <option>-t</option> option. The default time to gather data is 5
       seconds.
      </para>
          </callout>
          <callout arearefs="co.powertop.power">
            <para>
       When running powerTOP on a laptop, this line displays the ACPI
       information on how much power is currently being used and the
       estimated time until discharge of the battery. On servers, this
       information is not available.
      </para>
          </callout>
          <callout arearefs="co.powertop.culprits">
            <para>
       Shows what is causing the system to be more active than needed.
       powerTOP displays the top items causing your CPU to awake during
       the sampling period.
      </para>
          </callout>
          <callout arearefs="co.powertop.suggestions">
            <para>
       Suggestions on how to improve power usage for this machine.
      </para>
          </callout>
        </calloutlist>
      </example>
      <para>
    For more information, refer to the powerTOP project page at
    <link xlink:href="https://01.org/powertop"/>.
   </para>
    </sect2>
  </sect1>
  <sect1 xml:id="sec.tuning.power.options">
    <title>Special Tuning Options</title>
    <para>
   The following sections highlight some of the most relevant settings that
   you might want to touch.
  </para>
    <sect2 xml:id="sec.tuning.power.options.p-states">
      <title>Tuning Options for P-States</title>
      <para>
    The CPUfreq subsystem offers several tuning options for P-states: You
    can switch between the different governors, influence minimum or maximum
    CPU frequency to be used or change individual governor parameters.
   </para>
      <para>
    To switch to another governor at runtime, use
    <command>cpupower frequency-set</command> (or
    <command>cpufreq-set</command>) with the <option>-g</option> option. For
    example, running the following command (as <systemitem class="username">root</systemitem>) will activate the
    on-demand governor:
   </para>
      <screen>cpupower frequency-set -g ondemand</screen>
      <para>
    If you want the change in governor to persist also after a reboot or
    shutdown, use the pm-profiler as described in
    <xref linkend="sec.tuning.power.pm-profiler"/>.
   </para>
      <para>
    To set values for the minimum or maximum CPU frequency the governor may
    select, use the <option>-d</option> or <option>-u</option> option,
    respectively.
   </para>
      <para>
    Apart from the governor settings that can be influenced with
    <command>cpupower</command> or <command>cpufreq*</command>, you can also
    tune further governor parameters manually, for example,
    <xref linkend="pro.tuning.power.t-states.ignore.nice" xrefstyle="select:title"/>.
   </para>
      <procedure xml:id="pro.tuning.power.t-states.ignore.nice">
        <title>Ignoring Nice Values in Processor Usage</title>
        <para>
     One parameter you might want to change for the on-demand or
     conservative governor is <literal>ignore_nice_load</literal>.
    </para>
        <para>
     Each process has a niceness value associated with it. This value is
     used by the kernel to determine which processes require more processor
     time than others. The higher the nice value, the lower the priority of
     the process. Or: the <quote>nicer</quote> a process, the less CPU it
     will try to take from other processes.
    </para>
        <para>
     If the <literal>ignore_nice_load</literal> parameter for the on-demand
     or conservative governor is set to <literal>1</literal>, any process
     with a <literal>nice</literal> value will not be counted toward the
     overall processor usage. When <literal>ignore_nice_load</literal> is
     set to <literal>0</literal> (default value), all processes are counted
     toward the usage. Adjusting this parameter can be useful if you are
     running something that requires a lot of processor capacity but you do
     not care about the runtime.
    </para>
        <step>
          <para>
      Change to the subdirectory of the governor whose settings you want to
      modify, for example:
     </para>
          <screen>cd /sys/devices/system/cpu/cpu0/cpufreq/conservative/</screen>
        </step>
        <step>
          <para>
      Show the current value of <filename>ignore_nice_load</filename> with:
     </para>
          <screen>cat ignore_nice_load</screen>
        </step>
        <step>
          <para>
      To set the value to <literal>1</literal>, execute:
     </para>
          <screen>echo 1 &gt; ignore_nice_load</screen>
        </step>
      </procedure>
      <tip>
        <title>Using the Same Value for All Cores</title>
        <para>
     When setting the <literal>ignore_nice_load</literal> value for
     <literal>cpu0</literal>, the same value is automatically used for all
     cores. In this case, you do not need to repeat the steps above for each
     of the processors where you want to modify this governor parameter.
    </para>
      </tip>
      <para>
    Another parameter that significantly impacts the performance loss caused
    by dynamic frequency scaling is the sampling rate (rate at which the
    governor checks the current CPU load and adjusts the processor's
    frequency accordingly). Its default value depends on a BIOS value and it
    should be as low as possible. However, on modern systems, an appropriate
    sampling rate is set without manual intervention.
   </para>
    </sect2>
    <sect2 xml:id="sec.tuning.power.options-c.states">
      <title>Tuning Options for C-states</title>
      <para>
    By default, <phrase role="productname"><phrase os="osuse">openSUSE</phrase><phrase os="sles">SUSE Linux Enterprise Server</phrase><phrase os="sled">SUSE Linux Enterprise Desktop</phrase><phrase os="slerte">SUSE Linux Enterprise Real Time Extension</phrase></phrase> uses C-states appropriately. The only
    parameter that is relevant for optimization is the
    <literal>sched_mc_power_savings</literal> scheduler. Instead of
    distributing a workload across all cores with the effect that all cores
    are used only at a minimum level, the kernel can try to schedule
    processes on as few cores as possible, so that all others can go idle.
    This helps to save power, as it allows some processors to be idle for a
    longer time so they can reach a higher C-state. However, the actual
    savings depend on a number of factors. For example, how many processors
    are available and which C-states they support (especially deeper ones
    such as <literal>C3</literal> to <literal>C6</literal>).
   </para>
      <para>
    If <literal>sched_mc_power_savings</literal> is set to
    <literal>0</literal> (default value), no special scheduling is done. If
    it is set to <literal>1</literal>, the scheduler tries to consolidate
    the work onto the fewest number of processors possible in the case that
    all processors are a little busy.
<!--taroth 2010-04-28: according to trenn, a value of 2 is also
    supported, but not documented anywhere, therefore not mentioning for now-->
    To modify this parameter, proceed as follows:
   </para>
      <procedure xml:id="pro.tuning.power.c-states.ignore.scheduler">
        <title>Scheduling Processes on Cores</title>
        <step>
          <para>
      Become <systemitem class="username">root</systemitem> on a command line.
     </para>
        </step>
        <step>
          <para>
      To view the current value of
      <filename>sched_mc_power_savings</filename>, use the following
      command:
     </para>
          <screen>cpupower info -m</screen>
        </step>
        <step>
          <para>
      To set <literal>sched_mc_power_savings</literal> to
      <literal>1</literal>, execute:
     </para>
          <screen>cpupower set -m 1</screen>
        </step>
      </procedure>
    </sect2>
  </sect1>
  <sect1 xml:id="sec.tuning.power.pm-profiler">
    <title>Creating and Using Power Management Profiles</title>
    <para><phrase role="productname"><phrase os="osuse">openSUSE</phrase><phrase os="sles">SUSE Linux Enterprise Server</phrase><phrase os="sled">SUSE Linux Enterprise Desktop</phrase><phrase os="slerte">SUSE Linux Enterprise Real Time Extension</phrase></phrase> includes pm-profiler, intended for server use. It is a
   script infrastructure to enable or disable certain power management
   functions via configuration files. It allows you to define different
   profiles, each having a specific configuration file for defining
   different settings. A configuration template for new profiles can be
   found at
   <filename>/usr/share/doc/packages/pm-profiler/config.template</filename>.
   The template contains a number of parameters you can use for your
   profile, including comments on usage and links to further documentation.
   The individual profiles are stored in
   <filename>/etc/pm-profiler/</filename>. The profile that will be
   activated on system start, is defined in
   <filename>/etc/pm-profiler.conf</filename>.
  </para>
    <procedure xml:id="pro.tuning.power.pm-profile">
      <title>Creating and Switching Power Profiles</title>
      <para>
    To create a new profile, proceed as follows:
   </para>
      <step>
        <para>
     Create a directory in <filename>/etc/pm-profiler/</filename>,
     containing the profile name, for example:
    </para>
        <screen> mkdir /etc/pm-profiler/testprofile</screen>
      </step>
      <step>
        <para>
     To create the configuration file for the new profile, copy the profile
     template to the newly created directory:
    </para>
        <screen>cp /usr/share/doc/packages/pm-profiler/config.template \
     /etc/pm-profiler/testprofile/config</screen>
      </step>
      <step>
        <para>
     Edit the settings in
     <filename>/etc/pm-profiler/testprofile/config</filename> and save the
     file. You can also remove variables that you do not need—they
     will be handled like empty variables, the settings will not be touched
     at all.
    </para>
      </step>
      <step>
        <para>
     Edit <filename>/etc/pm-profiler.conf</filename>. The
     <systemitem>PM_PROFILER_PROFILE</systemitem> variable defines which
     profile will be activated on system start. If it has no value, the
     default system or kernel settings will be used. To set the newly
     created profile:
    </para>
        <screen>PM_PROFILER_PROFILE="<replaceable>testprofile</replaceable>"
    </screen>
        <para>
     The profile name you enter here must match the name you used in the
     path to the profile configuration file
     (<filename>/etc/pm-profiler/testprofile/config</filename>), not
     necessarily the <literal>NAME</literal> you used for the profile in the
     <filename>/etc/pm-profiler/testprofile/config</filename>.
    </para>
      </step>
      <step>
        <para>
     To activate the profile, run
    </para>
        <screen>sudo systemctl start pm-profiler</screen>
        <para>
     or
    </para>
        <screen>/usr/lib/pm-profiler/enable-profile testprofile </screen>
      </step>
    </procedure>
    <para>
   Though you need to manually create or modify a profile by editing the
   respective profile configuration file, you can use YaST to switch
   between different profiles. Start YaST and select <menuchoice><guimenu>System</guimenu><guimenu>Power Management</guimenu></menuchoice> to open the <guimenu>Power Management Settings</guimenu>.
   Alternatively, become <systemitem class="username">root</systemitem> and execute <command>yast2
   power-management</command> on a command line. The drop-down box shows the
   available profiles. <literal>Default</literal> means that the system
   default settings will be kept. Select the profile to use and click
   <guimenu>Finish</guimenu>.
  </para>
  </sect1>
  <sect1 xml:id="sec.tuning.power.trouble">
    <title>Troubleshooting</title>
    <variablelist>
      <varlistentry>
        <term>BIOS options enabled?</term>
        <listitem>
          <para>
      In order to make use of C-states or P-states, check your BIOS options:
     </para>
          <itemizedlist>
            <listitem>
              <para>
        To use C-states, make sure to enable <literal>CPU C State</literal>
        or similar options to benefit from power savings at idle.
       </para>
            </listitem>
            <listitem>
              <para>
        To use P-states and the CPUfreq governors, make sure to enable
        <literal>Processor Performance States</literal> options or similar.
       </para>
            </listitem>
          </itemizedlist>
          <para>
      In case of a CPU upgrade, make sure to upgrade your BIOS, too. The
      BIOS needs to know the new CPU and its frequency stepping in order to
      pass this information on to the operating system.
     </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>CPUfreq subsystem enabled?</term>
        <listitem>
          <para>
      In <phrase role="productname"><phrase os="osuse">openSUSE</phrase><phrase os="sles">SUSE Linux Enterprise Server</phrase><phrase os="sled">SUSE Linux Enterprise Desktop</phrase><phrase os="slerte">SUSE Linux Enterprise Real Time Extension</phrase></phrase>, the CPUfreq subsystem is enabled by default. To
      find out if the subsystem is currently enabled, check for the
      following path in your system:
      <filename>/sys/devices/system/cpu/cpufreq</filename> (or
      <filename>/sys/devices/system/cpu/cpu*/cpufreq</filename> for machines
      with multiple cores). If the <filename>cpufreq</filename> subdirectory
      exists, the subsystem is enabled.
     </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Log file information?</term>
        <listitem>
          <para>
      Check the <systemitem class="daemon">systemd</systemitem> journal (see <xref linkend="cha.journalctl"/>) for
      any output regarding the CPUfreq subsystem. Only severe errors are
      reported there.
     </para>
          <para>
      If you suspect problems with the CPUfreq subsystem on your machine,
      you can also enable additional debug output. To do so, either use
      <command>cpufreq.debug=7</command> as boot parameter or execute the
      following command as <systemitem class="username">root</systemitem>:
     </para>
          <screen>echo 7 &gt; /sys/module/cpufreq/parameters/debug</screen>
          <para>
      This will cause CPUfreq to log more information to
      <command>dmesg</command> on state transitions, which is useful for
      diagnosis. But as this additional output of kernel messages can be
      rather comprehensive, use it only if you are fairly sure that a
      problem exists.
     </para>
        </listitem>
      </varlistentry>
    </variablelist>
  </sect1>
  <sect1 xml:id="sec.tuning.power.more">
    <title>For More Information</title>
    <itemizedlist>
      <listitem>
        <para>
     A three-part, comprehensive article about tuning components with regard
     to power efficiency is available at the following URLs:
    </para>
        <itemizedlist>
          <listitem>
            <para><citetitle>Reduce Linux power consumption, Part 1: The CPUfreq
       subsystem</citetitle>, available at
       <link xlink:href="http://www.ibm.com/developerworks/linux/library/l-cpufreq-1/?ca=dgr-lnxw03ReduceLXPWR-P1dth-LX&amp;S_TACT=105AGX59&amp;S_CMP=grlnxw03"/></para>
          </listitem>
          <listitem>
            <para><citetitle>Reduce Linux power consumption, Part 2: General and
       governor-specific settings</citetitle>, available at
       <link xlink:href="http://www.ibm.com/developerworks/linux/library/l-cpufreq-2/?ca=dgr-lnxw03ReduceLXPWR-P1dth-LX&amp;S_TACT=105AGX59&amp;S_CMP=grlnxw03"/></para>
          </listitem>
          <listitem>
            <para><citetitle>Reduce Linux power consumption, Part 3: Tuning
       results</citetitle>, available at
       <link xlink:href="http://www.ibm.com/developerworks/linux/library/l-cpufreq-3/?ca=dgr-lnxw03ReduceLXPWR-P1dth-LX&amp;S_TACT=105AGX59&amp;S_CMP=grlnxw03"/></para>
          </listitem>
        </itemizedlist>
      </listitem>
      <!--taroth 2014-06-06: website no longer available, did quick research but
   could not find any new one/location, therefore commenting
   <listitem>
    <para>
     The LessWatts.org project deals with how to save power, reduce costs
     and increase efficiency on Linux systems. Find the project home page at
     <ulink
      url="http://www.lesswatts.org/"/>. The project page also
     holds an informative FAQs section at
     <ulink url="http://www.lesswatts.org/documentation/faq/index.php"/> and
     provides useful tips and tricks. For tips dealing with the CPU level,
     refer to <ulink
      url="http://www.lesswatts.org/tips/cpu.php"/>.
    </para>
   </listitem>-->
      <listitem>
        <para><!-- New location of the powerTOP homepage is here, at least: -->
     For more information about powerTOP, refer to
     <link xlink:href="https://01.org/powertop"/>.
    </para>
      </listitem>
      <listitem>
        <para>
     Platforms with a Baseboard Management Controller (BMC) may have
     additional power management configuration options accessible via the
     service processor. These configurations are vendor specific and
     therefore not subject of this guide. For more information, refer to the
     manuals provided by your vendor. For example, <citetitle>HP ProLiant
     Server Power Management on SUSE Linux Enterprise Server
     11—Integration Note </citetitle> provides detailed information
     how the HP platform specific power management features interact with
     the Linux Kernel. The paper is available from
     <link xlink:href="http://h18004.www1.hp.com/products/servers/technology/whitepapers/os-techwp.html"/>.
    </para>
      </listitem>
    </itemizedlist>
  </sect1>
</chapter>
